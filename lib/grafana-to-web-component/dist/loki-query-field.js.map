{"version":3,"file":"loki-query-field.js","mappings":"wIACA,EAA6C,CAAE,MAAO,EAAK,EAC3DA,EAAQ,GAAkBA,EAAQ,EAAwB,OAC1DA,EAAQ,EAAwB,CAE5B,YAAa,6DACb,SAAU,CACN,YAAa,GACjB,EACA,SAAU,CACN,CAAC,IAAK,GAAG,EACT,CAAC,IAAK,GAAG,EACT,CAAC,IAAK,GAAG,CACb,EACA,iBAAkB,CACd,CAAE,KAAM,IAAK,MAAO,GAAI,EACxB,CAAE,KAAM,IAAK,MAAO,GAAI,EACxB,CAAE,KAAM,IAAK,MAAO,GAAI,EACxB,CAAE,KAAM,IAAK,MAAO,GAAI,EACxB,CAAE,KAAM,IAAK,MAAO,GAAI,EACxB,CAAE,KAAM,IAAK,MAAO,GAAI,CAC5B,EACA,iBAAkB,CACd,CAAE,KAAM,IAAK,MAAO,GAAI,EACxB,CAAE,KAAM,IAAK,MAAO,GAAI,EACxB,CAAE,KAAM,IAAK,MAAO,GAAI,EACxB,CAAE,KAAM,IAAK,MAAO,GAAI,EACxB,CAAE,KAAM,IAAK,MAAO,GAAI,EACxB,CAAE,KAAM,IAAK,MAAO,GAAI,EACxB,CAAE,KAAM,IAAK,MAAO,GAAI,CAC5B,EACA,QAAS,CAAC,CACd,EAGA,IAAIC,EAAe,CACf,MACA,MACA,MACA,MACA,SACA,SACA,QACA,OACA,SACJ,EAGIC,EAAU,CAAC,OAAQ,SAAU,SAAU,SAAU,SAAS,EAG1DC,EAAqB,CAAC,cAAe,cAAc,EAGnDC,EAAsB,CACtB,kBACA,OACA,kBACA,aACA,gBACA,gBACA,gBACA,gBACA,mBACA,mBACA,qBACA,kBACA,iBACA,kBACJ,EAEIC,EAAkB,CAAC,KAAM,SAAS,EAElCC,EAAsB,IAAI,OAAOD,EAAgB,OAAO,SAAUE,EAAMC,EAAM,CAAE,MAAO,GAAG,OAAOD,EAAM,GAAG,EAAE,OAAOC,CAAI,CAAG,CAAC,EAAG,GAAG,EAEjIC,EAAY,CACZ,IACA,IACA,IACA,IACA,IACA,IACA,KACA,KACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,KACA,SACA,GACJ,EAEIC,EAAWT,EACV,OAAOC,CAAO,EACd,OAAOC,CAAkB,EACzB,OAAOC,CAAmB,EAC1B,OAAOC,CAAe,EAC3BL,EAAQ,GAAkB,CACtB,WAAY,GACZ,aAAc,GACd,aAAc,SACd,SAAUU,EACV,UAAWD,EACX,eAAgBH,EAEhB,QAAS,uBACT,QAAS,wEACT,OAAQ,cACR,YAAa,oBACb,aAAc,oBACd,UAAW,iCACX,cAAe,mCACf,YAAa,UAEb,UAAW,CACP,KAAM,CAEF,CAAC,2BAA4B,OAAQ,UAAU,EAE/C,CAAC,+BAAgC,KAAK,EAEtC,CAAC,UAAW,SAAS,EAErB,CACI,eACA,CACI,MAAO,CACH,YAAa,OACb,WAAY,YAChB,CACJ,CACJ,EAEA,CAAC,IAAK,SAAU,gBAAgB,EAChC,CAAC,IAAK,SAAU,gBAAgB,EAChC,CAAC,IAAK,SAAU,kBAAkB,EAElC,CAAE,QAAS,aAAc,EAEzB,CAAC,aAAc,WAAW,EAC1B,CAAC,mBAAoB,WAAW,EAChC,CACI,WACA,CACI,MAAO,CACH,aAAc,YACd,WAAY,EAChB,CACJ,CACJ,EAEA,CAAC,qBAAsB,QAAQ,EAC/B,CAAC,uCAAwC,cAAc,EACvD,CAAC,yCAA0C,cAAc,EACzD,CAAC,gDAAiD,YAAY,EAC9D,CAAC,gCAAiC,cAAc,EAChD,CAAC,oCAAqC,eAAe,EACrD,CAAC,6BAA8B,QAAQ,EACvC,CAAC,qBAAsB,QAAQ,CACnC,EACA,cAAe,CAEX,CAAC,gBAAiB,CAAE,MAAO,QAAS,CAAC,EACrC,CAAC,SAAU,QAAQ,EACnB,CAAC,WAAY,eAAe,EAC5B,CAAC,MAAO,uBAAuB,EAC/B,CAAC,IAAK,SAAU,MAAM,CAC1B,EACA,cAAe,CACX,CAAC,UAAW,QAAQ,EACpB,CAAC,WAAY,eAAe,EAC5B,CAAC,MAAO,uBAAuB,EAC/B,CAAC,IAAK,SAAU,MAAM,CAC1B,EACA,gBAAiB,CAEb,CAAC,gBAAiB,CAAE,MAAO,QAAS,CAAC,EACrC,CAAC,SAAU,QAAQ,EACnB,CAAC,WAAY,eAAe,EAC5B,CAAC,MAAO,uBAAuB,EAC/B,CAAC,IAAK,SAAU,MAAM,CAC1B,EACA,QAAS,CACL,CAAC,SAAU,KAAK,EAChB,CAAC,KAAM,aAAc,MAAM,CAC/B,EACA,WAAY,CAAC,CAAC,aAAc,OAAO,CAAC,CACxC,CACJ,C,wJC9KA,SAASK,GAAqB,CAK5B,MAAMC,EAAU,IAAI,IAGpB,OAAAA,EAAQ,IAAI,uBAAwB,KAAK,SAAS,CAAC,EAE5C,CAEL,iBAAmBC,GAAA,GACnB,kBAAoBA,GAAA,GACpB,gBAAkBA,GAAA,GAElB,IAAK,CAACC,EAAaC,EAAgBC,IAC1BJ,EAAQ,IAAIE,CAAG,GAAKE,EAG7B,WAAY,CAACF,EAAaC,EAAgBC,IAAiD,CACzF,MAAMC,EAAML,EAAQ,IAAIE,CAAG,EAC3B,OAAIG,IAAQ,OAGHA,IAAQ,OAERD,CAEX,EAEA,UAAW,CAACF,EAAaC,EAAgBC,IAA+C,CACtF,MAAMC,EAAML,EAAQ,IAAIE,CAAG,EAC3B,OAAIG,IAAQ,OACH,SAASA,EAAK,EAAE,EAEhBD,CAEX,EAEA,MAAO,CACLF,EACAI,EACAH,EACAI,IACS,CAELD,GAAU,KACZN,EAAQ,OAAOE,CAAG,EAElBF,EAAQ,IAAIE,EAAKI,EAAM,SAAS,CAAC,CAErC,EAEA,OAAQ,CAACJ,EAAaC,IAAyB,CAC7CH,EAAQ,OAAOE,CAAG,CACpB,EAEA,KAAM,CAACC,EAAgBI,IACd,MAAM,KAAKP,EAAQ,KAAK,CAAC,EAGlC,WAAY,IAAY,CACtB,QAAQ,IAAI,6BAA6B,CAC3C,EAEA,QAAS,IAEA,QAAQ,QAAQ,MAAS,EAGlC,MAAQG,GAGC,GAGT,MAAQK,GAEC,QAAQ,QAAQ,MAAS,CAEpC,CACF,CAEA,IAAIC,GAA+D,CACjE,eAAgBV,EAAmB,CACrC,EAEO,SAASW,IAAkE,CAEhF,OAAOD,EACT,CC9FO,MAAME,UAAuB,KAAM,CACxC,YAAYL,EAAc,CACxB,MAAM,wCAAwC,KAAK,UAAUA,CAAK,GAAG,CACvE,CACF,C,2DCYA,MAAMM,GAAgC,CACpC,CACE,KAAM,UACN,MAAO,KACP,WAAY,OACZ,UAAW,GACX,gBAAiB,EACnB,CACF,EAEMC,EAAwC,KAAsB,IAAKC,IAAO,CAC9E,KAAM,WACN,MAAOA,EAAE,MACT,WAAY,GAAGA,EAAE,YAAc,SAC/B,UAAW,GACX,gBAAiB,GACjB,OAAQA,EAAE,OACV,cAAeA,EAAE,aACnB,EAAE,EAEIC,EAAqC,KAAoB,IAAKD,IAAO,CACzE,KAAM,WACN,MAAOA,EAAE,MACT,WAAY,GAAGA,EAAE,YAAc,sBAC/B,UAAW,GACX,gBAAiB,GACjB,OAAQA,EAAE,OACV,cAAeA,EAAE,aACnB,EAAE,EAEIE,GAA+C,KAAmB,IAAKF,IAAO,CAClF,KAAM,WACN,MAAOA,EAAE,MACT,WAAY,GAAGA,EAAE,YAAc,SAC/B,UAAW,GACX,gBAAiB,GACjB,OAAQA,EAAE,OACV,cAAeA,EAAE,aACnB,EAAE,EAEIG,GAAqC,CAAC,UAAW,KAAM,KAAM,MAAO,MAAO,KAAM,IAAI,EAAE,IAAKC,IAAU,CAC1G,KAAM,WACN,MAAOA,EACP,WAAYA,CACd,EAAE,EAEIC,GAA4C,CAChD,CACE,KAAM,WACN,MAAO,mBACP,cAAe,yFACf,WAAY,oBACd,EACA,CACE,KAAM,WACN,MAAO,WACP,cAAe,uCACf,WAAY,YACd,EACA,CACE,KAAM,WACN,MAAO,QACP,cAAe,0FACf,WAAY,SACd,CACF,EAEMC,GAA4C,CAChD,CACE,KAAM,WACN,MAAO,WACP,cACE,wJACF,WAAY,UACd,EACA,CACE,KAAM,WACN,MAAO,eACP,cACE,sJACF,WAAY,cACd,CACF,EAEMC,GAA0B,CAC9B,CACE,SAAU,KACV,iBAAe,MAAgB,KAAgB,YAAY,EAC3D,UAAW,EACb,EACA,CACE,SAAU,KACV,iBAAe,MAAgB,KAAgB,eAAe,CAChE,EACA,CACE,SAAU,KACV,iBAAe,MAAgB,KAAgB,gBAAgB,EAC/D,UAAW,EACb,EACA,CACE,SAAU,KACV,iBAAe,MAAgB,KAAgB,mBAAmB,CACpE,CACF,EAEA,SAASC,GAAyBC,EAAkC,CAClE,OAAOF,GAAwB,OAAQG,GAAe,CAACD,GAAaC,EAAW,SAAS,EAAE,IACxF,CAAC,CAAE,SAAAC,EAAU,cAAAC,CAAc,KAAO,CAChC,KAAM,cACN,MAAO,GAAGD,OACV,WAAY,GAAGF,EAAYE,EAAS,QAAQ,IAAK,EAAE,EAAIA,SACvD,UAAW,GACX,cAAAC,CACF,EACF,CACF,CAEA,SAASC,GAA6BC,EAAS,GAAkB,CAC/D,MAAMC,EAA4B,CAAC,EACnC,OAAAA,EAAY,KAAK,CACf,KAAM,iBACN,MAAO,cACP,WAAY,GAAGD,yBACf,UAAW,GACX,iBAAe,MAAgB,KAAgB,UAAU,CAC3D,CAAC,EAEDC,EAAY,KAAK,CACf,KAAM,iBACN,MAAO,eACP,WAAY,GAAGD,gBACf,UAAW,GACX,iBAAe,MAAgB,KAAgB,WAAW,CAC5D,CAAC,EAEDC,EAAY,KAAK,CACf,KAAM,iBACN,MAAO,SACP,WAAY,GAAGD,UACf,iBAAe,MAAgB,KAAgB,MAAM,CACvD,CAAC,EAEDC,EAAY,KAAK,CACf,KAAM,iBACN,MAAO,aACP,WAAY,GAAGD,cACf,iBAAe,MAAgB,KAAgB,UAAU,CAC3D,CAAC,EAEDC,EAAY,KAAK,CACf,KAAM,iBACN,MAAO,OACP,WAAY,GAAGD,QACf,iBAAe,MAAgB,KAAgB,IAAI,CACrD,CAAC,EAEDC,EAAY,KAAK,CACf,KAAM,iBACN,MAAO,OACP,WAAY,GAAGD,QACf,iBAAe,MAAgB,KAAgB,IAAI,CACrD,CAAC,EAEMC,CACT,CAEA,eAAeC,GAAyBC,EAA6D,CAGnG,OAFgB,MAAMA,EAAa,WAAW,GAE/B,IAAKC,IAAU,CAC5B,KAAM,UACN,MAAOA,EACP,WAAYA,CACd,EAAE,CACJ,CAEA,eAAeC,GACbC,EACAH,EACuB,CAGvB,OAFmB,MAAMA,EAAa,cAAcG,CAAW,GAE7C,IAAKC,IAAW,CAChC,KAAM,aACN,MAAAA,EACA,WAAY,GAAGA,KACf,gBAAiB,EACnB,EAAE,CACJ,CAEA,eAAeC,GAAyBC,EAAkBN,EAA6D,CACrH,KAAM,CAAE,mBAAAO,CAAmB,EAAI,MAAMP,EAAa,sBAAsBM,CAAQ,EAEhF,OAAOC,EAAmB,IAAKH,IAAW,CACxC,KAAM,aACN,MAAAA,EACA,WAAYA,EACZ,gBAAiB,EACnB,EAAE,CACJ,CAEA,MAAMI,GAAU,CAAC,OAAQ,SAAU,UAAW,SAAU,QAAQ,EAEhE,eAAeC,GACbZ,EACAa,EACAC,EACAC,EACAL,EACAM,EACA,CACA,MAAMC,EAAa,IAAI,IAAIN,EAAO,EAC5BV,EAA4B,CAAC,EAE7BiB,EAA4BR,EAAmB,KAAMpC,GAAQA,IAAQ,OAAO,EAElF,GAAIuC,EAAS,CAEX,MAAMM,EAAQH,EAAmB,GAAK,cAClCD,GACFE,EAAW,OAAO,QAAQ,EAC1BhB,EAAY,KAAK,CACf,KAAM,SACN,MAAO,SAASkB,IAChB,WAAY,GAAGnB,UACf,iBAAe,MAAgB,KAAgB,MAAM,CACvD,CAAC,IAEDiB,EAAW,OAAO,MAAM,EACxBhB,EAAY,KAAK,CACf,KAAM,SACN,MAAO,OAAOkB,IACd,WAAY,GAAGnB,QACf,cAAekB,EACX,+CACA,MAAgB,KAAgB,IAAI,CAC1C,CAAC,GAIL,GAAIJ,EAAW,CACbG,EAAW,OAAO,QAAQ,EAE1B,MAAME,EAAQH,EAAmB,GAAK,cACtCf,EAAY,KAAK,CACf,KAAM,SACN,MAAO,SAASkB,IAChB,WAAY,GAAGnB,UACf,cAAekB,EACX,0CACA,MAAgB,KAAgB,MAAM,CAC5C,CAAC,EAIH,OADyB,MAAM,KAAKD,CAAU,EAAE,KAAK,EACpC,QAASG,GAAW,CACnCnB,EAAY,KAAK,CACf,KAAM,SACN,MAAOmB,EACP,WAAY,GAAGpB,IAASoB,IACxB,iBAAe,MAAgBA,CAAM,CACvC,CAAC,CACH,CAAC,EAEMnB,CACT,CAEO,eAAeoB,GACpBZ,EACAd,EACA2B,EACAnB,EACuB,CACvB,IAAIoB,EAAQd,EACRd,IACF4B,KAAQ,WAAQd,EAAU,IAAI,GAGhC,KAAM,CAAE,mBAAAC,EAAoB,QAAAG,EAAS,UAAAC,EAAW,QAAAC,CAAQ,EAAI,MAAMZ,EAAa,sBAAsBoB,CAAK,EACpGC,KAAiB,MAAkBD,CAAK,EAAE,gBAE1CvB,EAAS,GAAGsB,EAAW,GAAK,MAAM3B,EAAY,GAAK,OAEnD8B,EAAoB,MAAMb,GAC9BZ,EACAa,EACAC,EACAC,EACAL,EACAc,CACF,EACME,EAAiB3B,GAA6BC,CAAM,EAEpDC,EAAc,CAAC,GAAGwB,EAAmB,GAAGC,CAAc,EAe5D,OAZIF,GACFd,EAAmB,QAASpC,GAAQ,CAClC2B,EAAY,KAAK,CACf,KAAM,aACN,MAAO,GAAG3B,eACV,WAAY,GAAG0B,IAAS1B,IACxB,cAAe,IAAIA,0FACrB,CAAC,CACH,CAAC,EAICkD,EACK,CAAC,GAAGvB,CAAW,EAKjB,CAAC,GADYN,GAAa2B,EAAW,CAAC,EAAI5B,GAAyBC,CAAS,EAC3D,GAAGM,CAAW,CACxC,CAEO,eAAe0B,GACpBlB,EACAmB,EACAtB,EACAH,EACuB,CACvB,MAAM0B,EAAgBpB,EAAS,QAAQ,EAAE,SAAS,GAAG,EACjDoB,IAEFpB,KAAW,WAAQA,EAAU,IAAI,GAEnC,KAAM,CAAE,mBAAAC,EAAoB,QAAAG,EAAS,UAAAC,EAAW,QAAAC,CAAQ,EAAI,MAAMZ,EAAa,sBAAsBM,CAAQ,EACvGe,KAAiB,MAAkBf,CAAQ,EAAE,gBAEnD,IAAIR,EAA4B,CAAC,EAEjC,MAAMwB,EAAoB,MAAMb,GAC9B,KACAC,EACAC,EACAC,EACAL,EACAc,CACF,EACME,EAAiB3B,GAA6B,IAAI,EAEpD,CAAC6B,GAAS,CAACC,EACb5B,EAAc,CAAC,GAAGA,EAAa,GAAGT,GAA6B,GAAGiC,EAAmB,GAAGC,CAAc,EAC5FG,IACV5B,EAAc,CAAC,GAAGA,EAAa,GAAGwB,EAAmB,GAAGC,CAAc,GAGxE,MAAMI,EAAcxB,EAAY,SAAW,GAAKuB,EAAgB,GAAK,KAE/DE,EADSrB,EAAmB,OAAQH,GAAU,CAACD,EAAY,SAASC,CAAK,CAAC,EAClC,IAAKA,IAAW,CAC5D,KAAM,aACN,MAAAA,EACA,WAAYuB,EAAcvB,EAC1B,gBAAiB,EACnB,EAAE,EACF,OAAAN,EAAc,CAAC,GAAGA,EAAa,GAAG8B,CAAgB,EAE3C9B,CACT,CAEA,eAAe+B,GACbC,EACAC,EACA5B,EACAH,EACuB,CAEvB,OADe,MAAMA,EAAa,eAAe8B,EAAW3B,CAAW,GACzD,IAAKhB,IAAU,CAC3B,KAAM,cACN,MAAOA,EACP,WAAY4C,KAAgB,MAAgC5C,CAAI,EAAI,OAAI,MAAgCA,CAAI,IAC9G,EAAE,CACJ,CAEA,eAAe6C,GACb1B,EACAN,EACuB,CACvB,KAAM,CAAE,gBAAAiC,CAAgB,EAAI,MAAMjC,EAAa,sBAAsBM,CAAQ,EAS7E,MAAO,CAAC,GAP+B2B,EAAgB,IAAK7B,IAAW,CACrE,KAAM,aACN,MAAAA,EACA,WAAYA,EACZ,gBAAiB,EACnB,EAAE,EAE2B,GAAGhB,EAA2B,CAC7D,CAEA,eAAe8C,GAA+B5B,EAAkBN,EAAsC,CACpG,KAAM,CAAE,mBAAAO,CAAmB,EAAI,MAAMP,EAAa,sBAAsBM,CAAQ,EAQhF,MAAO,CAAC,GAP+BC,EAAmB,IAAKH,IAAW,CACxE,KAAM,aACN,MAAAA,EACA,WAAYA,EACZ,gBAAiB,EACnB,EAAE,CAEyB,CAC7B,CAEO,eAAe+B,GACpBC,EACApC,EACuB,CACvB,OAAQoC,EAAU,KAAM,CACtB,IAAK,QACL,IAAK,UAEH,MAAO,CACL,GAFyB,MAAMrC,GAAyBC,CAAY,EAGpE,GAAGnB,GACH,GAAGC,EACH,GAAGG,GACH,GAAGD,CACL,EACF,IAAK,WACH,OAAOE,GACT,IAAK,cACH,OAAOmB,GAAyB+B,EAAU,SAAUpC,CAAY,EAClE,IAAK,kCACH,OAAOE,GAAoCkC,EAAU,YAAapC,CAAY,EAChF,IAAK,oCACH,OAAO6B,GACLO,EAAU,UACVA,EAAU,cACVA,EAAU,YACVpC,CACF,EACF,IAAK,iBACH,OAAOkB,GAA4BkB,EAAU,SAAUA,EAAU,UAAWA,EAAU,SAAUpC,CAAY,EAC9G,IAAK,eACH,OAAOgC,GAA0BI,EAAU,SAAUpC,CAAY,EACnE,IAAK,iBACH,MAAO,CAAC,GAAGhB,EAAsB,GAAGF,CAAuB,EAC7D,IAAK,sBACH,OAAOoD,GAA+BE,EAAU,SAAUpC,CAAY,EACxE,IAAK,YACH,OAAOwB,GAAqBY,EAAU,SAAUA,EAAU,MAAOA,EAAU,YAAapC,CAAY,EACtG,QACE,MAAM,IAAIpB,EAAewD,CAAS,CACtC,CACF,C,eCvbA,SAASC,GAAKC,EAAkBC,EAAyC,CACvE,OAAOD,EAAKC,CAAS,CACvB,CAEA,SAASC,EAAKF,EAAkBG,EAA+B,CAC7D,IAAIC,EAA6BJ,EACjC,SAAW,CAACC,EAAWI,CAAY,IAAKF,EAMtC,GALAC,EAAUL,GAAKK,EAASH,CAAS,EAC7BG,IAAY,MAIZA,EAAQ,KAAK,KAAOC,EAEtB,OAAO,KAGX,OAAOD,CACT,CAEA,SAASE,EAAYN,EAAkBnD,EAAsB,CAC3D,OAAOA,EAAK,MAAMmD,EAAK,KAAMA,EAAK,EAAE,CACtC,CAEA,SAASO,GAAmB1D,EAAsB,CAEhD,MAAM2D,EAAS3D,EAAK,MAAM,EAAGA,EAAK,OAAS,CAAC,EAK5C,GAAIA,EAAK,WAAW,GAAG,GAAKA,EAAK,SAAS,GAAG,EAG3C,OAAO2D,EAAO,QAAQ,QAAS,GAAG,EAIpC,GAAI3D,EAAK,WAAW,GAAG,GAAKA,EAAK,SAAS,GAAG,EAG3C,OAAO2D,EAAO,QAAQ,QAAS,GAAG,EAIpC,GAAI3D,EAAK,WAAW,GAAG,GAAKA,EAAK,SAAS,GAAG,EAC3C,OAAO2D,EAGT,MAAM,IAAI,MAAM,2BAA2B3D,GAAM,CACnD,CA+DA,SAAS4D,GAAYC,EAA0BC,EAA+B,CAC5E,OAAOD,EAAa,MAAM,CAACE,EAAMC,IAAUD,IAASD,EAAWE,CAAK,CAAC,CACvE,CAEA,MAAMC,EAAgB,EAEhBC,GAAwB,CAC5B,CACE,MAAO,CAAC,CAAC,IAAQ,CAAC,EAClB,IAAKC,EACP,EACA,CACE,MAAO,CAAC,CAACF,EAAe,KAAU,IAAQ,CAAC,EAC3C,IAAKE,EACP,EACA,CACE,MAAO,CACL,CAAC,IAAK,EACN,CAAC,IAAoB,EACrB,CAACF,EAAe,KAAc,IAAoB,EAClD,CAACA,EAAe,IAA6B,EAC7C,CAAC,IAAY,EACb,CAACA,EAAe,IAA6B,EAC7C,CAAC,IAA6B,CAChC,EACA,IAAKG,EACP,EACA,CACE,MAAO,CAAC,CAAC,IAAK,CAAC,EACf,IAAKC,EACP,EACA,CACE,MAAO,CAAC,CAAC,KAAQ,IAAO,CAAC,EACzB,IAAKC,EACP,EACA,CACE,MAAO,CAAC,CAAC,IAAQ,CAAC,EAClB,IAAKC,EACP,EACA,CACE,MAAO,CAAC,CAAC,IAAY,CAAC,EACtB,IAAKC,EACP,EACA,CACE,MAAO,CAAC,CAACP,EAAe,IAAO,CAAC,EAChC,IAAKK,EACP,EACA,CACE,MAAO,CAAC,CAACL,EAAe,IAAK,CAAC,EAC9B,IAAKQ,EACP,EACA,CACE,MAAO,CAAC,CAACR,EAAe,IAAY,CAAC,EACrC,IAAKS,EACP,EACA,CACE,MAAO,CAAC,CAACT,EAAe,KAAa,KAAY,IAAqB,CAAC,EACvE,IAAK,KAAO,CAAE,KAAM,gBAAiB,EACvC,EACA,CACE,MAAO,CAAC,CAACA,EAAe,KAAe,IAAY,CAAC,EACpD,IAAKU,EACP,EACA,CACE,MAAO,CAAC,CAACV,EAAe,IAAU,EAAG,CAAC,IAAU,CAAC,EACjD,IAAKW,EACP,EACA,CACE,MAAO,CACL,CAACX,EAAe,IAAc,EAC9B,CAACA,EAAe,IAAU,EAC1B,CAACA,EAAe,IAAc,EAC9B,CAACA,EAAe,IAAU,CAC5B,EACA,IAAKY,EACP,CACF,EAEMC,GAAe,IAAI,IAA2B,CAClD,CAAC,KAAM,GAAG,EACV,CAAC,KAAM,IAAI,EACX,CAAC,MAAO,IAAI,EACZ,CAAC,MAAO,IAAI,CACd,CAAC,EAED,SAASC,GAAWC,EAA0C,CAC5D,OAAOF,GAAa,IAAIE,EAAO,IAAI,GAAK,IAC1C,CAEA,SAASC,GAASC,EAAyBlF,EAA4B,CACrE,GAAIkF,EAAY,KAAK,KAAO,KAC1B,OAAO,KAGT,MAAMC,EAAW9B,EAAK6B,EAAa,CAAC,CAAC,aAAc,IAAU,CAAC,CAAC,EAE/D,GAAIC,IAAa,KACf,OAAO,KAGT,MAAMH,EAASG,EAAS,YACxB,GAAIH,IAAW,KACb,OAAO,KAGT,MAAMI,EAAKL,GAAWC,CAAM,EAC5B,GAAII,IAAO,KACT,OAAO,KAGT,MAAMC,EAAYhC,EAAK6B,EAAa,CAAC,CAAC,YAAa,IAAM,CAAC,CAAC,EAE3D,GAAIG,IAAc,KAChB,OAAO,KAGT,MAAMC,EAAO7B,EAAY0B,EAAUnF,CAAI,EACjCZ,EAAQsE,GAAmBD,EAAY4B,EAAWrF,CAAI,CAAC,EAE7D,MAAO,CAAE,KAAAsF,EAAM,MAAAlG,EAAO,GAAAgG,CAAG,CAC3B,CAEA,SAASG,GAAUC,EAA0BxF,EAAuB,CAClE,GAAIwF,EAAa,KAAK,KAAO,KAC3B,MAAO,CAAC,EAGV,IAAIC,EAA8BpC,EAAKmC,EAAc,CAAC,CAAC,aAAc,IAAQ,CAAC,CAAC,EAE/E,MAAME,EAAkB,CAAC,EAEzB,KAAOD,IAAa,MAAM,CACxB,MAAMP,EAAc7B,EAAKoC,EAAU,CAAC,CAAC,YAAa,IAAO,CAAC,CAAC,EAC3D,GAAIP,IAAgB,KAAM,CACxB,MAAMjE,EAAQgE,GAASC,EAAalF,CAAI,EACpCiB,IAAU,MACZyE,EAAO,KAAKzE,CAAK,EAKrBwE,EAAWpC,EAAKoC,EAAU,CAAC,CAAC,aAAc,IAAQ,CAAC,CAAC,EAItD,OAAAC,EAAO,QAAQ,EAERA,CACT,CAEA,SAASd,GAAmBzB,EAAkBnD,EAAc2F,EAA+B,CACzF,MAAO,CACL,KAAM,eACN,YAAU,MAAsC3F,EAAM2F,CAAG,EAAE,KAAK,CAClE,CACF,CAEA,SAAShB,GAAiBxB,EAAkBnD,EAAc2F,EAA+B,CAEvF,MAAMC,EAAWvC,EAAKF,EAAM,CAC1B,CAAC,SAAU,IAAa,EACxB,CAAC,SAAU,IAAY,CACzB,CAAC,EAED,GAAIyC,IAAa,KACf,OAAO,KAGT,KAAM,CAAE,OAAAC,CAAO,EAAID,EAEnB,OAAIC,IAAW,KACN,KAGLA,EAAO,KAAK,KAAO,MAAWA,EAAO,KAAK,KAAO,KAC5CC,EAAqBD,EAAQ7F,EAAM2F,EAAK,EAAI,EAG9C,IACT,CAEA,SAASpB,GAAyBpB,EAAkBnD,EAAc2F,EAA+B,CAC/F,MAAMI,EAAc1C,EAAKF,EAAM,CAAC,CAAC,SAAU,IAAqB,CAAC,CAAC,EAClE,GAAI4C,IAAgB,KAClB,OAAO,KAET,MAAMC,EAAWD,EAAY,SAAS,YAAY,EAWlD,OAVIC,IAAa,MAII3C,EAAK2C,EAAU,CAClC,CAAC,aAAc,IAAoB,EACnC,CAAC,YAAa,IAAY,EAC1B,CAAC,aAAc,IAAQ,CACzB,CAAC,IAEoB,KACZ,KAGF,CACL,KAAM,cACN,YAAU,MAAsChG,EAAM2F,CAAG,EAAE,KAAK,CAClE,CACF,CAEA,SAASrB,GAAenB,EAAkBnD,EAAc2F,EAA+B,CAIrF,MAAMM,EAAe,CAAC9C,EAAK,KAAK,QAE1B0C,EAASxC,EAAKF,EAAM,CAAC,CAAC,SAAU,IAAO,CAAC,CAAC,EAC/C,GAAI0C,IAAW,KACb,OAAO,KAGT,MAAMK,EAAgB7C,EAAKwC,EAAQ,CAAC,CAAC,aAAc,IAAU,CAAC,CAAC,EAC/D,GAAIK,IAAkB,KACpB,OAAO,KAGT,MAAMvD,EAAYc,EAAYyC,EAAelG,CAAI,EAM3CmG,EAAgB9C,EAAKwC,EAAQ,CAAC,CAAC,SAAU,IAAQ,CAAC,CAAC,EACzD,GAAIM,IAAkB,KACpB,OAAO,KAGT,IAAIV,EAAWU,EAIXX,EAAkC,KACtC,KAAOA,IAAiB,MAAM,CAC5B,MAAMK,EAASJ,EAAS,OACxB,GAAII,IAAW,KACb,OAAO,KAGT,OAAQA,EAAO,KAAK,GAAI,CACtB,KAAK,KAEHJ,EAAWI,EACX,SACF,KAAK,KAEHL,EAAeK,EACf,SACF,QAEE,OAAO,IACX,EAOF,MAAM7E,EAHYuE,GAAUC,EAAcxF,CAAI,EAGhB,OAAQiB,GAAUA,EAAM,OAAS0B,CAAS,EAExE,MAAO,CACL,KAAM,oCACN,UAAAA,EACA,cAAesD,EACf,YAAAjF,CACF,CACF,CAEA,SAASoD,GAAoBgC,EAAepG,EAAcqG,EAA0C,CAIlG,MAAMC,EAAO,KAAO,MAAMtG,CAAI,EAGxBuG,EAAmBvG,EAAK,UAAU,EAAGqG,CAAc,EAAE,QAAQ,EAAE,OAC/DG,EAAWD,EAAmBF,EAAiBE,EAAmBF,EAElEI,EAASH,EAAK,SAASE,CAAQ,EAG/BE,EAAgB,CAAC,KAAQ,KAAY,KAA2B,IAA6B,EACnG,IAAIC,EAAW,GACf,EAAG,CACD,KAAM,CAAE,KAAAxD,CAAK,EAAIsD,EACjB,GAAKC,EAAc,SAASvD,EAAK,KAAK,EAAE,GAGpCsD,EAAO,MAAQD,GAAYC,EAAO,IAAMD,EAAU,CACpDG,EAAW,GACX,aAEKF,EAAO,KAAK,GAErB,GAAI,CAACE,EACH,OAAO,KAGT,MAAMrE,KAAQ,MAAkBtC,EAAM,CAAC,IAAU,CAAC,EAAE,OAAS,EAO7D,MAAO,CACL,KAAM,YACN,eARiB,MAAkBA,EAAM,CAAC,IAAyB,CAAC,EAEnE,IAAKiB,GAAsBA,EAAM,SAAS,IAAU,CAAC,EACrD,OAAQA,GAAkDA,IAAU,IAAI,EACxE,IAAKA,GAAsBwC,EAAYxC,EAAOjB,CAAI,CAAC,EAKpD,MAAAsC,EACA,YAAU,MAAsCtC,EAAMwG,CAAQ,EAAE,KAAK,CACvE,CACF,CAEA,SAASnC,GAAgBlB,EAAkBnD,EAAc2F,EAA+B,CAItF,MAAMiB,EAAcvD,EAAKF,EAAM,CAC7B,CAAC,YAAa,IAAI,EAClB,CAAC,YAAa,IAAO,CACvB,CAAC,EAED,OAAIyD,GAAe,KACVd,EAAqBc,EAAa5G,EAAM2F,EAAK,EAAK,EAM5CtC,EAAKF,EAAM,CACxB,CAAC,aAAcc,CAAa,EAC5B,CAAC,aAAc,IAAU,CAC3B,CAAC,GAEa,KACL,CACL,KAAM,SACR,EAIK,IACT,CAEA,SAASQ,GAAiBtB,EAAkBnD,EAAc2F,EAAwB,CAChF,MAAO,CACL,KAAM,UACR,CACF,CAEA,SAASnB,GAAgBrB,EAAkBnD,EAAc2F,EAA+B,CAEtF,MAAMtF,EADeL,EAAK,UAAU,EAAG2F,CAAG,EAAE,QAAQ,EACrB,SAAS,GAAG,EAE3C,OAAOG,EAAqB3C,EAAMnD,EAAM2F,EAAKtF,CAAS,CACxD,CAEA,SAASqE,GAAyBvB,EAAkBnD,EAAc2F,EAA+B,CAC/F,MAAME,EAASxC,EAAKF,EAAM,CAAC,CAAC,SAAU,IAAY,CAAC,CAAC,EACpD,GAAI0C,IAAW,KACb,OAAO,KAIT,MAAMxF,EADeL,EAAK,UAAU,EAAG2F,CAAG,EAAE,QAAQ,EACrB,SAAS,GAAG,EAE3C,OAAOG,EAAqBD,EAAQ7F,EAAM2F,EAAKtF,CAAS,CAC1D,CAEA,SAASyF,EAAqB3C,EAAkBnD,EAAc2F,EAAatF,EAAsC,CAG/G,MAAMmF,EAAenC,EAAKF,EAAM,CAAC,CAAC,aAAc,IAAQ,CAAC,CAAC,EAG1D,MAAI,CAACqC,GAAgBA,EAAa,GAAKG,EAC9B,KAGF,CACL,KAAM,iBACN,UAAAtF,EACA,SAAUL,EAAK,OAAO2F,EAAM,CAAC,IAAM,IACnC,YAAU,MAAsC3F,EAAM2F,CAAG,EAAE,KAAK,CAClE,CACF,CAEA,SAASxB,GAAgBhB,EAAkBnD,EAAc2F,EAA+B,CAKtF,MAAMkB,EAAQxD,EAAKF,EAAM,CAAC,CAAC,aAAc,IAAQ,CAAC,CAAC,EACnD,GAAI0D,IAAU,MAQR,CADgB7G,EAAK,MAAM6G,EAAM,KAAMlB,CAAG,EAC7B,KAAK,EAAE,SAAS,GAAG,EAClC,OAAO,KAIX,MAAMH,EACJrC,EAAK,KAAK,KAAOc,EACbZ,EAAKF,EAAM,CACT,CAAC,SAAU,IAAQ,EACnB,CAAC,SAAU,IAAQ,CACrB,CAAC,EACDA,EACN,OAAKqC,EAME,CACL,KAAM,kCACN,YAJkBD,GAAUC,EAAcxF,CAAI,CAKhD,EARS,IASX,CAEA,SAAS6E,GAAwB1B,EAAkBnD,EAAc2F,EAA+B,CAC9F,IAAIxE,KAAW,MAAsCnB,EAAM2F,CAAG,EAAE,KAAK,EACjEmB,EAAuC,KACvCjB,EAAS1C,EAAK,OAClB,KAAO0C,IAAW,MAAM,CACtB,GAAIA,EAAO,KAAK,KAAO,KAAe,CACpCiB,EAAoBjB,EACpB,MAEFA,EAASA,EAAO,OAGlB,OAAIiB,GAAmB,KAAK,KAAO,OACjC3F,EAAWA,EAAS,MAAM,EAAG2F,EAAkB,IAAI,GAG9C,CACL,KAAM,sBACN,SAAA3F,CACF,CACF,CAQA,SAAS4F,GAAaT,EAAYtG,EAAcgH,EAAsC,CAIpF,MAAMT,EAAmBvG,EAAK,QAAQ,EAAE,OAClC2F,EAAMY,EAAmBS,EAAYT,EAAmBS,EACxDC,EAAMX,EAAK,SAASX,CAAG,EAC7B,EACE,IAAIsB,EAAI,OAAStB,GAAOsB,EAAI,KAAOtB,EAAK,CACtC,KAAM,CAAE,KAAAxC,CAAK,EAAI8D,EACjB,GAAI9D,EAAK,KAAK,QACZ,OAAOA,QAGJ8D,EAAI,KAAK,GAClB,OAAO,IACT,CAEO,SAASC,GAAalH,EAAc2F,EAA+B,CAIxE,GAAI3F,IAAS,GACX,MAAO,CACL,KAAM,OACR,EAGF,MAAMsG,EAAO,KAAO,MAAMtG,CAAI,EAOxBmH,EAAiBJ,GAAaT,EAAMtG,EAAM2F,CAAG,EAE7CsB,EAAME,GAAkB,KAAOA,EAAe,OAAO,EAAIb,EAAK,SAASX,CAAG,EAE1EyB,EAAcH,EAAI,KAElBI,EAAM,CAACJ,EAAI,KAAK,EAAE,EACxB,KAAOA,EAAI,OAAO,GAChBI,EAAI,KAAKJ,EAAI,KAAK,EAAE,EAGtB,QAASK,KAAYpD,GACnB,QAASZ,KAAQgE,EAAS,MACxB,GAAI1D,GAAYN,EAAM+D,CAAG,EAAG,CAC1B,MAAMpE,EAAYqE,EAAS,IAAIF,EAAapH,EAAM2F,CAAG,EACrD,GAAI1C,EACF,OAAOA,EAMf,OAAO,IACT,CCrpBA,MAAMsE,GAA+B,EAE9B,SAASC,IAAwD,CACtE,MAAO,CAgBL,UAAW,EACb,CACF,CAEA,SAASC,GAA4BC,EAAsBC,EAA0D,CACnH,OAAQD,EAAM,CACZ,IAAK,WACH,OAAOC,EAAO,UAAU,mBAAmB,KAC7C,IAAK,WACH,OAAOA,EAAO,UAAU,mBAAmB,SAC7C,IAAK,UACH,OAAOA,EAAO,UAAU,mBAAmB,QAC7C,IAAK,aACH,OAAOA,EAAO,UAAU,mBAAmB,KAC7C,IAAK,cACH,OAAOA,EAAO,UAAU,mBAAmB,WAC7C,IAAK,UACH,OAAOA,EAAO,UAAU,mBAAmB,YAC7C,IAAK,SACH,OAAOA,EAAO,UAAU,mBAAmB,MAC7C,IAAK,cACH,OAAOA,EAAO,UAAU,mBAAmB,cAC7C,IAAK,iBACH,OAAOA,EAAO,UAAU,mBAAmB,UAC7C,QACE,MAAM,IAAIlI,EAAeiI,CAAI,CACjC,CACF,CACO,SAASE,GACdD,EACA9G,EAC8C,CAiD9C,MAAO,CACL,kBAAmB,CAAC,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAG,EAC/D,uBAlD6B,CAC7BgH,EACArB,IAC+E,CAC/E,MAAMsB,EAAOD,EAAM,kBAAkBrB,CAAQ,EACvCuB,EACJD,GAAQ,KACJH,EAAO,MAAM,KAAK,CAChB,gBAAiBnB,EAAS,WAC1B,cAAeA,EAAS,WACxB,YAAasB,EAAK,YAClB,UAAWA,EAAK,SAClB,CAAC,EACDH,EAAO,MAAM,cAAcnB,CAAQ,EAGnCwB,EAAgB,CACpB,OAAQxB,EAAS,OACjB,WAAYA,EAAS,UACvB,EACMyB,EAASJ,EAAM,YAAYG,CAAa,EACxC/E,EAAYiE,GAAaW,EAAM,SAAS,EAAGI,CAAM,EAEvD,OAD2BhF,GAAa,KAAOD,GAAeC,EAAWpC,CAAY,EAAI,QAAQ,QAAQ,CAAC,CAAC,GACjF,KAAMqH,GAAU,CAIxC,MAAMC,EAAiBD,EAAM,OAAO,SAAS,EAAE,OAiB/C,MAAO,CAAE,YAhBmDA,EAAM,IAAI,CAACnE,EAAMC,KAAW,CACtF,KAAMyD,GAA4B1D,EAAK,KAAM4D,CAAM,EACnD,MAAO5D,EAAK,MACZ,WAAYA,EAAK,WACjB,gBAAiBA,EAAK,UAAYwD,GAA+B,OACjE,OAAQxD,EAAK,OACb,cAAeA,EAAK,cACpB,SAAUC,EAAM,SAAS,EAAE,SAASmE,EAAgB,GAAG,EACvD,MAAAJ,EACA,QAAShE,EAAK,gBACV,CACE,GAAI,+BACJ,MAAO,EACT,EACA,MACN,EAAE,CACmB,CACvB,CAAC,CACH,CAKA,CACF,C,gBCjGO,MAAMqE,EAAuB,CAClC,YACUC,EACAC,EAAyB,CAAE,QAAS,CAAC,CAAE,EAC/C,CAFQ,sBAAAD,EACA,gBAAAC,CACP,CAEK,cAAc5C,EAAyB,CAK7C,MAAO,IAJeA,EAAO,IAC1BzE,GAAU,GAAGA,EAAM,OAAOA,EAAM,SAAM,OAAgCA,EAAM,KAAK,IACpF,EAEyB,KAAK,GAAG,IACnC,CAEA,YAAa,CACX,SAAO,SAAM,KAAK,WAAW,OAAO,EACjC,IAAKsH,GAAoCA,EAAQ,MAAM,IAAI,EAC3D,OAAO,EACP,KAAK,EACL,MAAM,CACX,CAEA,MAAM,cAAcvH,EAAuB,CAAC,EAAG,CAC7C,GAAIA,EAAY,SAAW,EAEzB,OAAO,KAAK,iBAAiB,aAAa,EAE5C,MAAMjC,EAAO,MAAM,KAAK,gBAAgBiC,CAAW,EAC7CwH,EAAqB,OAAO,KAAKzJ,CAAI,EACrC0J,EAAiB,IAAI,IAAIzH,EAAY,IAAK0H,GAAMA,EAAE,IAAI,CAAC,EAC7D,OAAOF,EAAmB,OAAQvH,GAAU,CAACwH,EAAe,IAAIxH,CAAK,CAAC,CACxE,CAEA,MAAM,eAAe0B,EAAmB3B,EAAsB,CAC5D,OAAIA,EAAY,SAAW,EAElB,MAAM,KAAK,iBAAiB,eAAe2B,CAAS,GAGhD,MAAM,KAAK,gBAAgB3B,CAAW,GACvC2B,CAAS,GAAK,CAAC,CAC7B,CAEA,MAAM,sBAAsBxB,EAAkB,CAC5C,OAAO,MAAM,KAAK,iBAAiB,sBAAsBA,CAAQ,CACnE,CAEA,MAAM,gBAAgBuE,EAAiB,CACrC,OAAO,MAAM,KAAK,iBAAiB,gBAAgB,KAAK,cAAcA,CAAM,CAAC,EAAE,KAAM3G,GAASA,GAAQ,CAAC,CAAC,CAC1G,CACF,C,gBC/CA,MAAM4J,GAAmE,CACvE,SAAU,GACV,YAAa,GAGb,qBAAsB,GACtB,QAAS,GACT,SAAU,GACV,qBAAsB,EACtB,YAAa,MACb,QAAS,CAAE,QAAS,EAAM,EAC1B,oBAAqB,GACrB,mBAAoB,EACpB,QAAS,CAGP,IAAK,EACL,OAAQ,CACV,EACA,oBAAqB,OACrB,UAAW,CACT,SAAU,SACV,sBAAuB,EACvB,WAAY,SACZ,wBAAyB,CAC3B,EACA,qBAAsB,GACtB,QAASnB,GAAkB,EAC3B,gBAAiB,GACjB,SAAU,IACZ,EASMoB,GAAuB,EAEvBC,EAAU,QAGhB,IAAIC,GAAyB,GAE7B,SAASC,GAAYpB,EAAgB,CAC/BmB,KAA2B,KAC7BA,GAAyB,GACzBnB,EAAO,UAAU,SAAS,CAAE,GAAIkB,CAAQ,CAAC,EAEzClB,EAAO,UAAU,yBAAyBkB,EAAS,IAAe,EAClElB,EAAO,UAAU,yBAAyBkB,EAAS,GAAqB,EAE5E,CAEA,MAAMG,GAAY,CAACC,EAAsBC,KAChC,CACL,aAAW;AAAA,uBACQD,EAAM,MAAM,OAAO;AAAA,0BAChBA,EAAM,WAAW,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA,MAM7C,eAAa;AAAA;AAAA,oBAEGC;AAAA,uBACGD,EAAM,WAAW;AAAA;AAAA;AAAA,KAItC,GA4KF,GAzKyB,CAAC,CAAE,QAAAV,EAAS,OAAAY,EAAQ,WAAAC,EAAY,aAAAC,EAAc,WAAAC,EAAY,YAAAJ,EAAa,SAAAK,CAAS,IAAa,CACpH,MAAMC,KAAK,KAAO,EAEZC,KAAsB,UAAOjK,GAAoB,CAAC,EAClDkK,KAAe,UAAuB,IAAI,EAE1CC,KAAkBC,EAAA,GAAUN,EAAW,gBAAgB,EACvDhB,KAAasB,EAAA,GAAUrB,CAAO,EAC9BsB,KAAgBD,EAAA,GAAUR,CAAU,EACpCU,KAAYF,EAAA,GAAUT,CAAM,EAE5BY,KAA8B,UAA4B,IAAI,EAE9Dd,KAAQ,MAAU,EAClBe,EAAShB,GAAUC,EAAOC,CAAW,KAE3C,aAAU,IAED,IAAM,CACXa,EAA4B,UAAU,CACxC,EACC,CAAC,CAAC,EAEL,MAAME,GAAiB,CAACtC,EAAgBuC,IAAyB,CAC/D,MAAMC,EAAwB,CAC5B,CACE,MAAO,IAAIxC,EAAO,MAAM,EAAG,EAAG,EAAG,CAAC,EAClC,QAAS,CACP,UAAWqC,EAAO,YAClB,YAAa,EACf,CACF,CACF,EAEA,IAAII,EAAuB,CAAC,EAE5B,MAAMC,EAA8B,IAAM,CACxC,MAAMxC,EAAQqC,EAAO,SAAS,EAE9B,GAAI,CAACrC,EACH,OAGF,MAAMyC,EAAgBzC,EAAM,eAAe,IAAM,EAAIsC,EAAwB,CAAC,EAC9EC,EAAavC,EAAM,iBAAiBuC,EAAYE,CAAa,CAC/D,EAEAD,EAAgB,EAChBH,EAAO,wBAAwBG,CAAe,CAChD,EAEME,MAAkB,YAAS,MAAOtI,GAAkB,CACxDsH,EAAStH,CAAK,CAChB,EAAG,GAAI,EAEP,OACE,gBAAC,OACC,aAAYuI,EAAA,GAAU,WAAW,WAAW,UAC5C,UAAWR,EAAO,UAElB,IAAKN,CAAA,EAEL,gBAAC,KACC,iBAAkBD,EAAoB,QACtC,QAAAd,GACA,SAAUE,EACV,MAAOQ,EACP,YAAc1B,GAAW,CACvBoB,GAAYpB,CAAM,CACpB,EACA,QAAS,CAACuC,EAAQvC,IAAW,CAE3B,MAAM8C,EAAkBP,EAAO,iBAA0B,kBAAoBV,EAAI,EAAK,EAEtFU,EAAO,sBAAsB,IAAM,CACjCO,EAAgB,IAAI,EAAK,EACzBX,EAAU,QAAQI,EAAO,SAAS,CAAC,CACrC,CAAC,EACDA,EAAO,wBAAyBQ,GAAM,CACpC,MAAM7C,EAAQqC,EAAO,SAAS,EAC9B,GAAI,CAACrC,EACH,OAEF,MAAM5F,EAAQ4F,EAAM,SAAS,EAQvB8C,OANJ,MACE1I,EACAqH,EAAW,kBAAkBrH,EAAO,IAAqB,EACzD4F,EAAM,gBAAgB,CACxB,GAAK,CAAC,GAEe,IAAI,CAAC,CAAE,MAAA+C,GAAO,GAAGC,EAAS,KAAO,CACtD,QAAS,GACPD,GAAQ,kBAAkBA,MAAW,kFAEvC,SAAUjD,EAAO,eAAe,MAChC,GAAGkD,EACL,EAAE,EAEFN,GAAgBtI,CAAK,EACrB0F,EAAO,OAAO,gBAAgBE,EAAO,QAAS8C,EAAO,CACvD,CAAC,EACD,MAAM9J,EAAe,IAAIuH,GAAuBuB,EAAgB,QAASrB,CAAU,EAC7EwC,EAAqBlD,GAAsBD,EAAQ9G,CAAY,EAU/DkK,EAA4E,CAChF,GAAGD,EACH,uBAAwB,CAACjD,EAAOrB,EAAUwE,EAASC,KAG7Cf,EAAO,SAAS,GAAG,KAAOrC,EAAM,GAC3B,CAAE,YAAa,CAAC,CAAE,EAEpBiD,EAAmB,uBAAuBjD,EAAOrB,EAAUwE,EAASC,EAAK,CAEpF,EAEM,CAAE,QAAAC,CAAQ,EAAIvD,EAAO,UAAU,+BAA+BkB,EAASkC,CAA2B,EAExGhB,EAA4B,QAAUmB,EAKtC,MAAMC,GAAe,IAAM,CACzB,MAAMC,EAAe1B,EAAa,QAClC,GAAI0B,IAAiB,KAAM,CACzB,MAAMC,EAAcnB,EAAO,iBAAiB,EAC5CkB,EAAa,MAAM,OAAS,GAAGC,EAAczC,OAC7C,MAAM0C,EAAaF,EAAa,YAChClB,EAAO,OAAO,CAAE,MAAOoB,EAAY,OAAQD,CAAY,CAAC,EAE5D,EAEAnB,EAAO,uBAAuBiB,EAAY,EAC1CA,GAAa,EAGbjB,EAAO,WACLvC,EAAO,OAAO,MAAQA,EAAO,QAAQ,MACrC,IAAM,CACJkC,EAAc,QAAQK,EAAO,SAAS,CAAC,CACzC,EACA,kBAAoBV,CACtB,EAEAU,EAAO,qBAAqB,IAAM,CAChCO,EAAgB,IAAI,EAAI,EACpBP,EAAO,SAAS,EAAE,KAAK,IAAM,IAC/BA,EAAO,QAAQ,GAAI,+BAAgC,CAAC,CAAC,CAEzD,CAAC,EAEDD,GAAetC,EAAQuC,CAAM,CAC/B,EACF,CACF,CAEJ,C,kDClQIN,EAAY,SAAUxK,EAAO,CAC7B,IAAImM,KAAM,UAAOnM,CAAK,EACtB,OAAAmM,EAAI,QAAUnM,EACPmM,CACX,EACA,QAAe3B,C","sources":["webpack://GrafanaToWebComponent/./.yarn/__virtual__/@grafana-monaco-logql-virtual-a88ff9128e/0/cache/@grafana-monaco-logql-npm-0.0.7-d8a55872d9-cce4a8ed8a.zip/node_modules/@grafana/monaco-logql/index.js","webpack://GrafanaToWebComponent/./public/app/plugins/datasource/loki/components/monaco-query-field/getOverrideServices.ts","webpack://GrafanaToWebComponent/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/NeverCaseError.ts","webpack://GrafanaToWebComponent/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/completions.ts","webpack://GrafanaToWebComponent/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/situation.ts","webpack://GrafanaToWebComponent/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/index.ts","webpack://GrafanaToWebComponent/./public/app/plugins/datasource/loki/components/monaco-query-field/monaco-completion-provider/CompletionDataProvider.ts","webpack://GrafanaToWebComponent/./public/app/plugins/datasource/loki/components/monaco-query-field/MonacoQueryField.tsx","webpack://GrafanaToWebComponent/./.yarn/__virtual__/react-use-virtual-dd7926f458/0/cache/react-use-npm-17.4.0-0ef4521544-0889da919b.zip/node_modules/react-use/esm/useLatest.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.monarchlanguage = exports.languageConfiguration = void 0;\nexports.languageConfiguration = {\n    // the default separators except `@$`\n    wordPattern: /(-?\\d*\\.\\d\\w*)|([^`~!#%^&*()\\-=+\\[{\\]}\\\\|;:'\",.<>\\/?\\s]+)/g,\n    comments: {\n        lineComment: \"#\",\n    },\n    brackets: [\n        [\"{\", \"}\"],\n        [\"[\", \"]\"],\n        [\"(\", \")\"],\n    ],\n    autoClosingPairs: [\n        { open: \"{\", close: \"}\" },\n        { open: \"[\", close: \"]\" },\n        { open: \"(\", close: \")\" },\n        { open: '\"', close: '\"' },\n        { open: \"'\", close: \"'\" },\n        { open: \"`\", close: \"`\" },\n    ],\n    surroundingPairs: [\n        { open: \"{\", close: \"}\" },\n        { open: \"[\", close: \"]\" },\n        { open: \"(\", close: \")\" },\n        { open: '\"', close: '\"' },\n        { open: \"'\", close: \"'\" },\n        { open: \"`\", close: \"`\" },\n        { open: \"<\", close: \">\" },\n    ],\n    folding: {},\n};\n// LogQL built-in aggregation operators\n// https://grafana.com/docs/loki/latest/logql/metric_queries/#built-in-aggregation-operators\nvar aggregations = [\n    \"sum\",\n    \"avg\",\n    \"min\",\n    \"max\",\n    \"stddev\",\n    \"stdvar\",\n    \"count\",\n    \"topk\",\n    \"bottomk\",\n];\n// LogQL parser expressions\n// https://grafana.com/docs/loki/latest/logql/log_queries/#parser-expression\nvar parsers = [\"json\", \"logfmt\", \"regexp\", \"unpack\", \"pattern\"];\n// LogQL format expressions\n// https://grafana.com/docs/loki/latest/logql/log_queries/#parser-expression\nvar format_expressions = [\"line_format\", \"label_format\"];\n// LogQL vector aggregations\n// https://grafana.com/docs/loki/latest/logql/metric_queries/#range-vector-aggregation\nvar vector_aggregations = [\n    \"count_over_time\",\n    \"rate\",\n    \"bytes_over_time\",\n    \"bytes_rate\",\n    \"avg_over_time\",\n    \"sum_over_time\",\n    \"min_over_time\",\n    \"max_over_time\",\n    \"stdvar_over_time\",\n    \"stddev_over_time\",\n    \"quantile_over_time\",\n    \"first_over_time\",\n    \"last_over_time\",\n    \"absent_over_time\",\n];\n// LogQL by and without clauses\nvar vector_matching = [\"by\", \"without\"];\n// Produce a regex matching elements : (by|without)\nvar vectorMatchingRegex = \"(\".concat(vector_matching.reduce(function (prev, curr) { return \"\".concat(prev, \"|\").concat(curr); }), \")\");\n// LogQL Operators\nvar operators = [\n    \"+\",\n    \"-\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \"^\",\n    \"==\",\n    \"!=\",\n    \">\",\n    \"<\",\n    \">=\",\n    \"<=\",\n    \"|=\",\n    \"!=\",\n    \"|~\",\n    \"!~\",\n    \"and\",\n    \"or\",\n    \"unless\",\n    \"|\",\n];\n// Merging all the keywords in one list\nvar keywords = aggregations\n    .concat(parsers)\n    .concat(format_expressions)\n    .concat(vector_aggregations)\n    .concat(vector_matching);\nexports.monarchlanguage = {\n    ignoreCase: false,\n    defaultToken: \"\",\n    tokenPostfix: \".logql\",\n    keywords: keywords,\n    operators: operators,\n    vectorMatching: vectorMatchingRegex,\n    // we include these common regular expressions\n    symbols: /[=><!~?:&|+\\-*\\/^%]+/,\n    escapes: /\\\\(?:[abfnrtv\\\\\"']|x[0-9A-Fa-f]{1,4}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8})/,\n    digits: /\\d+(_+\\d+)*/,\n    octaldigits: /[0-7]+(_+[0-7]+)*/,\n    binarydigits: /[0-1]+(_+[0-1]+)*/,\n    hexdigits: /[[0-9a-fA-F]+(_+[0-9a-fA-F]+)*/,\n    integersuffix: /(ll|LL|u|U|l|L)?(ll|LL|u|U|l|L)?/,\n    floatsuffix: /[fFlL]?/,\n    // The main tokenizer for our languages\n    tokenizer: {\n        root: [\n            // 'by', 'without' and vector matching\n            [/@vectorMatching\\s*(?=\\()/, \"type\", \"@clauses\"],\n            // labels\n            [/[a-z_]\\w*(?=\\s*(=|!=|=~|!~))/, \"tag\"],\n            // comments\n            [/(^#.*$)/, \"comment\"],\n            // all keywords have the same color\n            [\n                /[a-zA-Z_]\\w*/,\n                {\n                    cases: {\n                        \"@keywords\": \"type\",\n                        \"@default\": \"identifier\",\n                    },\n                },\n            ],\n            // strings\n            [/\"/, \"string\", \"@string_double\"],\n            [/'/, \"string\", \"@string_single\"],\n            [/`/, \"string\", \"@string_backtick\"],\n            // whitespace\n            { include: \"@whitespace\" },\n            // delimiters and operators\n            [/[{}()\\[\\]]/, \"@brackets\"],\n            [/[<>](?!@symbols)/, \"@brackets\"],\n            [\n                /@symbols/,\n                {\n                    cases: {\n                        \"@operators\": \"delimiter\",\n                        \"@default\": \"\",\n                    },\n                },\n            ],\n            // numbers\n            [/\\d+(?:ms|[smhdwy])/, \"number\"],\n            [/\\d*\\d+[eE]([\\-+]?\\d+)?(@floatsuffix)/, \"number.float\"],\n            [/\\d*\\.\\d+([eE][\\-+]?\\d+)?(@floatsuffix)/, \"number.float\"],\n            [/0[xX][0-9a-fA-F']*[0-9a-fA-F](@integersuffix)/, \"number.hex\"],\n            [/0[0-7']*[0-7](@integersuffix)/, \"number.octal\"],\n            [/0[bB][0-1']*[0-1](@integersuffix)/, \"number.binary\"],\n            [/\\d[\\d']*\\d(@integersuffix)/, \"number\"],\n            [/\\d(@integersuffix)/, \"number\"],\n        ],\n        string_double: [\n            // Set to token: number to differentiate color\n            [/\\{\\{(.*?)\\}\\}/, { token: 'number' }],\n            [/[^\\\\\"]/, \"string\"],\n            [/@escapes/, \"string.escape\"],\n            [/\\\\./, \"string.escape.invalid\"],\n            [/\"/, \"string\", \"@pop\"],\n        ],\n        string_single: [\n            [/[^\\\\']+/, \"string\"],\n            [/@escapes/, \"string.escape\"],\n            [/\\\\./, \"string.escape.invalid\"],\n            [/'/, \"string\", \"@pop\"],\n        ],\n        string_backtick: [\n            // Set to token: number to differentiate color\n            [/\\{\\{(.*?)\\}\\}/, { token: 'number' }],\n            [/[^\\\\`]/, \"string\"],\n            [/@escapes/, \"string.escape\"],\n            [/\\\\./, \"string.escape.invalid\"],\n            [/`/, \"string\", \"@pop\"],\n        ],\n        clauses: [\n            [/[^(,)]/, \"tag\"],\n            [/\\)/, \"identifier\", \"@pop\"],\n        ],\n        whitespace: [[/[ \\t\\r\\n]+/, \"white\"]],\n    },\n};\n","import { monacoTypes } from '@grafana/ui';\n\n// this thing here is a workaround in a way.\n// what we want to achieve, is that when the autocomplete-window\n// opens, the \"second, extra popup\" with the extra help,\n// also opens automatically.\n// but there is no API to achieve it.\n// the way to do it is to implement the `storageService`\n// interface, and provide our custom implementation,\n// which will default to `true` for the correct string-key.\n// unfortunately, while the typescript-interface exists,\n// it is not exported from monaco-editor,\n// so we cannot rely on typescript to make sure\n// we do it right. all we can do is to manually\n// lookup the interface, and make sure we code our code right.\n// our code is a \"best effort\" approach,\n// i am not 100% how the `scope` and `target` things work,\n// but so far it seems to work ok.\n// i would use an another approach, if there was one available.\n\nfunction makeStorageService() {\n  // we need to return an object that fulfills this interface:\n  // https://github.com/microsoft/vscode/blob/ff1e16eebb93af79fd6d7af1356c4003a120c563/src/vs/platform/storage/common/storage.ts#L37\n  // unfortunately it is not export from monaco-editor\n\n  const strings = new Map<string, string>();\n\n  // we want this to be true by default\n  strings.set('expandSuggestionDocs', true.toString());\n\n  return {\n    // we do not implement the on* handlers\n    onDidChangeValue: (data: unknown): void => undefined,\n    onDidChangeTarget: (data: unknown): void => undefined,\n    onWillSaveState: (data: unknown): void => undefined,\n\n    get: (key: string, scope: unknown, fallbackValue?: string): string | undefined => {\n      return strings.get(key) ?? fallbackValue;\n    },\n\n    getBoolean: (key: string, scope: unknown, fallbackValue?: boolean): boolean | undefined => {\n      const val = strings.get(key);\n      if (val !== undefined) {\n        // the interface docs say the value will be converted\n        // to a boolean but do not specify how, so we improvise\n        return val === 'true';\n      } else {\n        return fallbackValue;\n      }\n    },\n\n    getNumber: (key: string, scope: unknown, fallbackValue?: number): number | undefined => {\n      const val = strings.get(key);\n      if (val !== undefined) {\n        return parseInt(val, 10);\n      } else {\n        return fallbackValue;\n      }\n    },\n\n    store: (\n      key: string,\n      value: string | boolean | number | undefined | null,\n      scope: unknown,\n      target: unknown\n    ): void => {\n      // the interface docs say if the value is nullish, it should act as delete\n      if (value === null || value === undefined) {\n        strings.delete(key);\n      } else {\n        strings.set(key, value.toString());\n      }\n    },\n\n    remove: (key: string, scope: unknown): void => {\n      strings.delete(key);\n    },\n\n    keys: (scope: unknown, target: unknown): string[] => {\n      return Array.from(strings.keys());\n    },\n\n    logStorage: (): void => {\n      console.log('logStorage: not implemented');\n    },\n\n    migrate: (): Promise<void> => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    },\n\n    isNew: (scope: unknown): boolean => {\n      // we create a new storage for every session, we do not persist it,\n      // so we return `true`.\n      return true;\n    },\n\n    flush: (reason?: unknown): Promise<void> => {\n      // we do not implement this\n      return Promise.resolve(undefined);\n    },\n  };\n}\n\nlet overrideServices: monacoTypes.editor.IEditorOverrideServices = {\n  storageService: makeStorageService(),\n};\n\nexport function getOverrideServices(): monacoTypes.editor.IEditorOverrideServices {\n  // One instance of this for every query editor\n  return overrideServices;\n}\n","// This helper class is used to make typescript warn you when you miss a case-block in a switch statement.\n// For example:\n//\n// const x:'A'|'B'|'C' = 'A';\n//\n// switch(x) {\n//   case 'A':\n//     // something\n//   case 'B':\n//     // something\n//   default:\n//     throw new NeverCaseError(x);\n// }\n//\n//\n// TypeScript detect the missing case and display an error.\n\nexport class NeverCaseError extends Error {\n  constructor(value: never) {\n    super(`Unexpected case in switch statement: ${JSON.stringify(value)}`);\n  }\n}\n","import { trimEnd } from 'lodash';\n\nimport { escapeLabelValueInExactSelector } from '../../../languageUtils';\nimport { isQueryWithParser } from '../../../queryUtils';\nimport { explainOperator } from '../../../querybuilder/operations';\nimport { LokiOperationId } from '../../../querybuilder/types';\nimport { AGGREGATION_OPERATORS, RANGE_VEC_FUNCTIONS, BUILT_IN_FUNCTIONS } from '../../../syntax';\n\nimport { CompletionDataProvider } from './CompletionDataProvider';\nimport { NeverCaseError } from './NeverCaseError';\nimport type { Situation, Label } from './situation';\n\nexport type CompletionType =\n  | 'HISTORY'\n  | 'FUNCTION'\n  | 'DURATION'\n  | 'LABEL_NAME'\n  | 'LABEL_VALUE'\n  | 'PATTERN'\n  | 'PARSER'\n  | 'LINE_FILTER'\n  | 'PIPE_OPERATION';\n\ntype Completion = {\n  type: CompletionType;\n  label: string;\n  insertText: string;\n  detail?: string;\n  documentation?: string;\n  triggerOnInsert?: boolean;\n  isSnippet?: boolean;\n};\n\nconst LOG_COMPLETIONS: Completion[] = [\n  {\n    type: 'PATTERN',\n    label: '{}',\n    insertText: '{$0}',\n    isSnippet: true,\n    triggerOnInsert: true,\n  },\n];\n\nconst AGGREGATION_COMPLETIONS: Completion[] = AGGREGATION_OPERATORS.map((f) => ({\n  type: 'FUNCTION',\n  label: f.label,\n  insertText: `${f.insertText ?? ''}($0)`, // i don't know what to do when this is nullish. it should not be.\n  isSnippet: true,\n  triggerOnInsert: true,\n  detail: f.detail,\n  documentation: f.documentation,\n}));\n\nconst FUNCTION_COMPLETIONS: Completion[] = RANGE_VEC_FUNCTIONS.map((f) => ({\n  type: 'FUNCTION',\n  label: f.label,\n  insertText: `${f.insertText ?? ''}({$0}[\\\\$__auto])`, // i don't know what to do when this is nullish. it should not be.\n  isSnippet: true,\n  triggerOnInsert: true,\n  detail: f.detail,\n  documentation: f.documentation,\n}));\n\nconst BUILT_IN_FUNCTIONS_COMPLETIONS: Completion[] = BUILT_IN_FUNCTIONS.map((f) => ({\n  type: 'FUNCTION',\n  label: f.label,\n  insertText: `${f.insertText ?? ''}($0)`,\n  isSnippet: true,\n  triggerOnInsert: true,\n  detail: f.detail,\n  documentation: f.documentation,\n}));\n\nconst DURATION_COMPLETIONS: Completion[] = ['$__auto', '1m', '5m', '10m', '30m', '1h', '1d'].map((text) => ({\n  type: 'DURATION',\n  label: text,\n  insertText: text,\n}));\n\nconst UNWRAP_FUNCTION_COMPLETIONS: Completion[] = [\n  {\n    type: 'FUNCTION',\n    label: 'duration_seconds',\n    documentation: 'Will convert the label value in seconds from the go duration format (e.g 5m, 24s30ms).',\n    insertText: 'duration_seconds()',\n  },\n  {\n    type: 'FUNCTION',\n    label: 'duration',\n    documentation: 'Short version of duration_seconds().',\n    insertText: 'duration()',\n  },\n  {\n    type: 'FUNCTION',\n    label: 'bytes',\n    documentation: 'Will convert the label value to raw bytes applying the bytes unit (e.g. 5 MiB, 3k, 1G).',\n    insertText: 'bytes()',\n  },\n];\n\nconst LOGFMT_ARGUMENT_COMPLETIONS: Completion[] = [\n  {\n    type: 'FUNCTION',\n    label: '--strict',\n    documentation:\n      'Strict parsing. The logfmt parser stops scanning the log line and returns early with an error when it encounters any poorly formatted key/value pair.',\n    insertText: '--strict',\n  },\n  {\n    type: 'FUNCTION',\n    label: '--keep-empty',\n    documentation:\n      'Retain standalone keys with empty value. The logfmt parser retains standalone keys (keys without a value) as labels with value set to empty string.',\n    insertText: '--keep-empty',\n  },\n];\n\nconst LINE_FILTER_COMPLETIONS = [\n  {\n    operator: '|=',\n    documentation: explainOperator(LokiOperationId.LineContains),\n    afterPipe: true,\n  },\n  {\n    operator: '!=',\n    documentation: explainOperator(LokiOperationId.LineContainsNot),\n  },\n  {\n    operator: '|~',\n    documentation: explainOperator(LokiOperationId.LineMatchesRegex),\n    afterPipe: true,\n  },\n  {\n    operator: '!~',\n    documentation: explainOperator(LokiOperationId.LineMatchesRegexNot),\n  },\n];\n\nfunction getLineFilterCompletions(afterPipe: boolean): Completion[] {\n  return LINE_FILTER_COMPLETIONS.filter((completion) => !afterPipe || completion.afterPipe).map(\n    ({ operator, documentation }) => ({\n      type: 'LINE_FILTER',\n      label: `${operator} \"\"`,\n      insertText: `${afterPipe ? operator.replace('|', '') : operator} \"$0\"`,\n      isSnippet: true,\n      documentation,\n    })\n  );\n}\n\nfunction getPipeOperationsCompletions(prefix = ''): Completion[] {\n  const completions: Completion[] = [];\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'line_format',\n    insertText: `${prefix}line_format \"{{.$0}}\"`,\n    isSnippet: true,\n    documentation: explainOperator(LokiOperationId.LineFormat),\n  });\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'label_format',\n    insertText: `${prefix}label_format`,\n    isSnippet: true,\n    documentation: explainOperator(LokiOperationId.LabelFormat),\n  });\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'unwrap',\n    insertText: `${prefix}unwrap`,\n    documentation: explainOperator(LokiOperationId.Unwrap),\n  });\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'decolorize',\n    insertText: `${prefix}decolorize`,\n    documentation: explainOperator(LokiOperationId.Decolorize),\n  });\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'drop',\n    insertText: `${prefix}drop`,\n    documentation: explainOperator(LokiOperationId.Drop),\n  });\n\n  completions.push({\n    type: 'PIPE_OPERATION',\n    label: 'keep',\n    insertText: `${prefix}keep`,\n    documentation: explainOperator(LokiOperationId.Keep),\n  });\n\n  return completions;\n}\n\nasync function getAllHistoryCompletions(dataProvider: CompletionDataProvider): Promise<Completion[]> {\n  const history = await dataProvider.getHistory();\n\n  return history.map((expr) => ({\n    type: 'HISTORY',\n    label: expr,\n    insertText: expr,\n  }));\n}\n\nasync function getLabelNamesForSelectorCompletions(\n  otherLabels: Label[],\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  const labelNames = await dataProvider.getLabelNames(otherLabels);\n\n  return labelNames.map((label) => ({\n    type: 'LABEL_NAME',\n    label,\n    insertText: `${label}=`,\n    triggerOnInsert: true,\n  }));\n}\n\nasync function getInGroupingCompletions(logQuery: string, dataProvider: CompletionDataProvider): Promise<Completion[]> {\n  const { extractedLabelKeys } = await dataProvider.getParserAndLabelKeys(logQuery);\n\n  return extractedLabelKeys.map((label) => ({\n    type: 'LABEL_NAME',\n    label,\n    insertText: label,\n    triggerOnInsert: false,\n  }));\n}\n\nconst PARSERS = ['json', 'logfmt', 'pattern', 'regexp', 'unpack'];\n\nasync function getParserCompletions(\n  prefix: string,\n  hasJSON: boolean,\n  hasLogfmt: boolean,\n  hasPack: boolean,\n  extractedLabelKeys: string[],\n  hasParserInQuery: boolean\n) {\n  const allParsers = new Set(PARSERS);\n  const completions: Completion[] = [];\n  // We use this to improve documentation specifically for level label as it is tied to showing color-coded logs volume\n  const hasLevelInExtractedLabels = extractedLabelKeys.some((key) => key === 'level');\n\n  if (hasJSON) {\n    // We show \"detected\" label only if there is no previous parser in the query\n    const extra = hasParserInQuery ? '' : ' (detected)';\n    if (hasPack) {\n      allParsers.delete('unpack');\n      completions.push({\n        type: 'PARSER',\n        label: `unpack${extra}`,\n        insertText: `${prefix}unpack`,\n        documentation: explainOperator(LokiOperationId.Unpack),\n      });\n    } else {\n      allParsers.delete('json');\n      completions.push({\n        type: 'PARSER',\n        label: `json${extra}`,\n        insertText: `${prefix}json`,\n        documentation: hasLevelInExtractedLabels\n          ? 'Use it to get log-levels in the histogram'\n          : explainOperator(LokiOperationId.Json),\n      });\n    }\n  }\n\n  if (hasLogfmt) {\n    allParsers.delete('logfmt');\n    // We show \"detected\" label only if there is no previous parser in the query\n    const extra = hasParserInQuery ? '' : ' (detected)';\n    completions.push({\n      type: 'PARSER',\n      label: `logfmt${extra}`,\n      insertText: `${prefix}logfmt`,\n      documentation: hasLevelInExtractedLabels\n        ? 'Get detected levels in the histogram'\n        : explainOperator(LokiOperationId.Logfmt),\n    });\n  }\n\n  const remainingParsers = Array.from(allParsers).sort();\n  remainingParsers.forEach((parser) => {\n    completions.push({\n      type: 'PARSER',\n      label: parser,\n      insertText: `${prefix}${parser}`,\n      documentation: explainOperator(parser),\n    });\n  });\n\n  return completions;\n}\n\nexport async function getAfterSelectorCompletions(\n  logQuery: string,\n  afterPipe: boolean,\n  hasSpace: boolean,\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  let query = logQuery;\n  if (afterPipe) {\n    query = trimEnd(logQuery, '| ');\n  }\n\n  const { extractedLabelKeys, hasJSON, hasLogfmt, hasPack } = await dataProvider.getParserAndLabelKeys(query);\n  const hasQueryParser = isQueryWithParser(query).queryWithParser;\n\n  const prefix = `${hasSpace ? '' : ' '}${afterPipe ? '' : '| '}`;\n\n  const parserCompletions = await getParserCompletions(\n    prefix,\n    hasJSON,\n    hasLogfmt,\n    hasPack,\n    extractedLabelKeys,\n    hasQueryParser\n  );\n  const pipeOperations = getPipeOperationsCompletions(prefix);\n\n  const completions = [...parserCompletions, ...pipeOperations];\n\n  // Let's show label options only if query has parser\n  if (hasQueryParser) {\n    extractedLabelKeys.forEach((key) => {\n      completions.push({\n        type: 'LABEL_NAME',\n        label: `${key} (detected)`,\n        insertText: `${prefix}${key}`,\n        documentation: `\"${key}\" was suggested based on the content of your log lines for the label filter expression.`,\n      });\n    });\n  }\n\n  // If we have parser, we don't need to consider line filters\n  if (hasQueryParser) {\n    return [...completions];\n  }\n  // With a space between the pipe and the cursor, we omit line filters\n  // E.g. `{label=\"value\"} | `\n  const lineFilters = afterPipe && hasSpace ? [] : getLineFilterCompletions(afterPipe);\n  return [...lineFilters, ...completions];\n}\n\nexport async function getLogfmtCompletions(\n  logQuery: string,\n  flags: boolean,\n  otherLabels: string[],\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  const trailingComma = logQuery.trimEnd().endsWith(',');\n  if (trailingComma) {\n    // The user is typing a new label, so we remove the last comma\n    logQuery = trimEnd(logQuery, ', ');\n  }\n  const { extractedLabelKeys, hasJSON, hasLogfmt, hasPack } = await dataProvider.getParserAndLabelKeys(logQuery);\n  const hasQueryParser = isQueryWithParser(logQuery).queryWithParser;\n\n  let completions: Completion[] = [];\n\n  const parserCompletions = await getParserCompletions(\n    '| ',\n    hasJSON,\n    hasLogfmt,\n    hasPack,\n    extractedLabelKeys,\n    hasQueryParser\n  );\n  const pipeOperations = getPipeOperationsCompletions('| ');\n\n  if (!flags && !trailingComma) {\n    completions = [...completions, ...LOGFMT_ARGUMENT_COMPLETIONS, ...parserCompletions, ...pipeOperations];\n  } else if (!trailingComma) {\n    completions = [...completions, ...parserCompletions, ...pipeOperations];\n  }\n\n  const labelPrefix = otherLabels.length === 0 || trailingComma ? '' : ', ';\n  const labels = extractedLabelKeys.filter((label) => !otherLabels.includes(label));\n  const labelCompletions: Completion[] = labels.map((label) => ({\n    type: 'LABEL_NAME',\n    label,\n    insertText: labelPrefix + label,\n    triggerOnInsert: false,\n  }));\n  completions = [...completions, ...labelCompletions];\n\n  return completions;\n}\n\nasync function getLabelValuesForMetricCompletions(\n  labelName: string,\n  betweenQuotes: boolean,\n  otherLabels: Label[],\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  const values = await dataProvider.getLabelValues(labelName, otherLabels);\n  return values.map((text) => ({\n    type: 'LABEL_VALUE',\n    label: text,\n    insertText: betweenQuotes ? escapeLabelValueInExactSelector(text) : `\"${escapeLabelValueInExactSelector(text)}\"`,\n  }));\n}\n\nasync function getAfterUnwrapCompletions(\n  logQuery: string,\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  const { unwrapLabelKeys } = await dataProvider.getParserAndLabelKeys(logQuery);\n\n  const labelCompletions: Completion[] = unwrapLabelKeys.map((label) => ({\n    type: 'LABEL_NAME',\n    label,\n    insertText: label,\n    triggerOnInsert: false,\n  }));\n\n  return [...labelCompletions, ...UNWRAP_FUNCTION_COMPLETIONS];\n}\n\nasync function getAfterKeepAndDropCompletions(logQuery: string, dataProvider: CompletionDataProvider) {\n  const { extractedLabelKeys } = await dataProvider.getParserAndLabelKeys(logQuery);\n  const labelCompletions: Completion[] = extractedLabelKeys.map((label) => ({\n    type: 'LABEL_NAME',\n    label,\n    insertText: label,\n    triggerOnInsert: false,\n  }));\n\n  return [...labelCompletions];\n}\n\nexport async function getCompletions(\n  situation: Situation,\n  dataProvider: CompletionDataProvider\n): Promise<Completion[]> {\n  switch (situation.type) {\n    case 'EMPTY':\n    case 'AT_ROOT':\n      const historyCompletions = await getAllHistoryCompletions(dataProvider);\n      return [\n        ...historyCompletions,\n        ...LOG_COMPLETIONS,\n        ...AGGREGATION_COMPLETIONS,\n        ...BUILT_IN_FUNCTIONS_COMPLETIONS,\n        ...FUNCTION_COMPLETIONS,\n      ];\n    case 'IN_RANGE':\n      return DURATION_COMPLETIONS;\n    case 'IN_GROUPING':\n      return getInGroupingCompletions(situation.logQuery, dataProvider);\n    case 'IN_LABEL_SELECTOR_NO_LABEL_NAME':\n      return getLabelNamesForSelectorCompletions(situation.otherLabels, dataProvider);\n    case 'IN_LABEL_SELECTOR_WITH_LABEL_NAME':\n      return getLabelValuesForMetricCompletions(\n        situation.labelName,\n        situation.betweenQuotes,\n        situation.otherLabels,\n        dataProvider\n      );\n    case 'AFTER_SELECTOR':\n      return getAfterSelectorCompletions(situation.logQuery, situation.afterPipe, situation.hasSpace, dataProvider);\n    case 'AFTER_UNWRAP':\n      return getAfterUnwrapCompletions(situation.logQuery, dataProvider);\n    case 'IN_AGGREGATION':\n      return [...FUNCTION_COMPLETIONS, ...AGGREGATION_COMPLETIONS];\n    case 'AFTER_KEEP_AND_DROP':\n      return getAfterKeepAndDropCompletions(situation.logQuery, dataProvider);\n    case 'IN_LOGFMT':\n      return getLogfmtCompletions(situation.logQuery, situation.flags, situation.otherLabels, dataProvider);\n    default:\n      throw new NeverCaseError(situation);\n  }\n}\n","import type { Tree, SyntaxNode } from '@lezer/common';\n\nimport {\n  parser,\n  VectorAggregationExpr,\n  String,\n  Selector,\n  RangeAggregationExpr,\n  Range,\n  PipelineExpr,\n  PipelineStage,\n  Matchers,\n  Matcher,\n  LogQL,\n  LogRangeExpr,\n  LogExpr,\n  Logfmt,\n  Identifier,\n  Grouping,\n  Expr,\n  LiteralExpr,\n  MetricExpr,\n  UnwrapExpr,\n  DropLabelsExpr,\n  KeepLabelsExpr,\n  DropLabels,\n  KeepLabels,\n  ParserFlag,\n  LabelExtractionExpression,\n  LabelExtractionExpressionList,\n} from '@grafana/lezer-logql';\n\nimport { getLogQueryFromMetricsQueryAtPosition, getNodesFromQuery } from '../../../queryUtils';\n\ntype Direction = 'parent' | 'firstChild' | 'lastChild' | 'nextSibling';\ntype NodeType = number;\n\ntype Path = Array<[Direction, NodeType]>;\n\nfunction move(node: SyntaxNode, direction: Direction): SyntaxNode | null {\n  return node[direction];\n}\n\nfunction walk(node: SyntaxNode, path: Path): SyntaxNode | null {\n  let current: SyntaxNode | null = node;\n  for (const [direction, expectedNode] of path) {\n    current = move(current, direction);\n    if (current === null) {\n      // we could not move in the direction, we stop\n      return null;\n    }\n    if (current.type.id !== expectedNode) {\n      // the reached node has wrong type, we stop\n      return null;\n    }\n  }\n  return current;\n}\n\nfunction getNodeText(node: SyntaxNode, text: string): string {\n  return text.slice(node.from, node.to);\n}\n\nfunction parseStringLiteral(text: string): string {\n  // If it is a string-literal, it is inside quotes of some kind\n  const inside = text.slice(1, text.length - 1);\n\n  // Very simple un-escaping:\n\n  // Double quotes\n  if (text.startsWith('\"') && text.endsWith('\"')) {\n    // NOTE: this is not 100% perfect, we only unescape the double-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\\"/gm, '\"');\n  }\n\n  // Single quotes\n  if (text.startsWith(\"'\") && text.endsWith(\"'\")) {\n    // NOTE: this is not 100% perfect, we only unescape the single-quote,\n    // there might be other characters too\n    return inside.replace(/\\\\'/gm, \"'\");\n  }\n\n  // Backticks\n  if (text.startsWith('`') && text.endsWith('`')) {\n    return inside;\n  }\n\n  throw new Error(`Invalid string literal: ${text}`);\n}\n\nexport type LabelOperator = '=' | '!=' | '=~' | '!~';\n\nexport type Label = {\n  name: string;\n  value: string;\n  op: LabelOperator;\n};\n\nexport type Situation =\n  | {\n      type: 'EMPTY';\n    }\n  | {\n      type: 'AT_ROOT';\n    }\n  | {\n      type: 'IN_LOGFMT';\n      otherLabels: string[];\n      flags: boolean;\n      logQuery: string;\n    }\n  | {\n      type: 'IN_RANGE';\n    }\n  | {\n      type: 'IN_AGGREGATION';\n    }\n  | {\n      type: 'IN_GROUPING';\n      logQuery: string;\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME';\n      otherLabels: Label[];\n    }\n  | {\n      type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME';\n      labelName: string;\n      betweenQuotes: boolean;\n      otherLabels: Label[];\n    }\n  | {\n      type: 'AFTER_SELECTOR';\n      afterPipe: boolean;\n      hasSpace: boolean;\n      logQuery: string;\n    }\n  | {\n      type: 'AFTER_UNWRAP';\n      logQuery: string;\n    }\n  | {\n      type: 'AFTER_KEEP_AND_DROP';\n      logQuery: string;\n    };\n\ntype Resolver = {\n  paths: NodeType[][];\n  fun: (node: SyntaxNode, text: string, pos: number) => Situation | null;\n};\n\nfunction isPathMatch(resolverPath: NodeType[], cursorPath: number[]): boolean {\n  return resolverPath.every((item, index) => item === cursorPath[index]);\n}\n\nconst ERROR_NODE_ID = 0;\n\nconst RESOLVERS: Resolver[] = [\n  {\n    paths: [[Selector]],\n    fun: resolveSelector,\n  },\n  {\n    paths: [[ERROR_NODE_ID, Matchers, Selector]],\n    fun: resolveSelector,\n  },\n  {\n    paths: [\n      [LogQL],\n      [RangeAggregationExpr],\n      [ERROR_NODE_ID, LogRangeExpr, RangeAggregationExpr],\n      [ERROR_NODE_ID, LabelExtractionExpressionList],\n      [LogRangeExpr],\n      [ERROR_NODE_ID, LabelExtractionExpressionList],\n      [LabelExtractionExpressionList],\n    ],\n    fun: resolveLogfmtParser,\n  },\n  {\n    paths: [[LogQL]],\n    fun: resolveTopLevel,\n  },\n  {\n    paths: [[String, Matcher]],\n    fun: resolveMatcher,\n  },\n  {\n    paths: [[Grouping]],\n    fun: resolveLabelsForGrouping,\n  },\n  {\n    paths: [[LogRangeExpr]],\n    fun: resolveLogRange,\n  },\n  {\n    paths: [[ERROR_NODE_ID, Matcher]],\n    fun: resolveMatcher,\n  },\n  {\n    paths: [[ERROR_NODE_ID, Range]],\n    fun: resolveDurations,\n  },\n  {\n    paths: [[ERROR_NODE_ID, LogRangeExpr]],\n    fun: resolveLogRangeFromError,\n  },\n  {\n    paths: [[ERROR_NODE_ID, LiteralExpr, MetricExpr, VectorAggregationExpr]],\n    fun: () => ({ type: 'IN_AGGREGATION' }),\n  },\n  {\n    paths: [[ERROR_NODE_ID, PipelineStage, PipelineExpr]],\n    fun: resolvePipeError,\n  },\n  {\n    paths: [[ERROR_NODE_ID, UnwrapExpr], [UnwrapExpr]],\n    fun: resolveAfterUnwrap,\n  },\n  {\n    paths: [\n      [ERROR_NODE_ID, DropLabelsExpr],\n      [ERROR_NODE_ID, DropLabels],\n      [ERROR_NODE_ID, KeepLabelsExpr],\n      [ERROR_NODE_ID, KeepLabels],\n    ],\n    fun: resolveAfterKeepAndDrop,\n  },\n];\n\nconst LABEL_OP_MAP = new Map<string, LabelOperator>([\n  ['Eq', '='],\n  ['Re', '=~'],\n  ['Neq', '!='],\n  ['Nre', '!~'],\n]);\n\nfunction getLabelOp(opNode: SyntaxNode): LabelOperator | null {\n  return LABEL_OP_MAP.get(opNode.name) ?? null;\n}\n\nfunction getLabel(matcherNode: SyntaxNode, text: string): Label | null {\n  if (matcherNode.type.id !== Matcher) {\n    return null;\n  }\n\n  const nameNode = walk(matcherNode, [['firstChild', Identifier]]);\n\n  if (nameNode === null) {\n    return null;\n  }\n\n  const opNode = nameNode.nextSibling;\n  if (opNode === null) {\n    return null;\n  }\n\n  const op = getLabelOp(opNode);\n  if (op === null) {\n    return null;\n  }\n\n  const valueNode = walk(matcherNode, [['lastChild', String]]);\n\n  if (valueNode === null) {\n    return null;\n  }\n\n  const name = getNodeText(nameNode, text);\n  const value = parseStringLiteral(getNodeText(valueNode, text));\n\n  return { name, value, op };\n}\n\nfunction getLabels(selectorNode: SyntaxNode, text: string): Label[] {\n  if (selectorNode.type.id !== Selector) {\n    return [];\n  }\n\n  let listNode: SyntaxNode | null = walk(selectorNode, [['firstChild', Matchers]]);\n\n  const labels: Label[] = [];\n\n  while (listNode !== null) {\n    const matcherNode = walk(listNode, [['lastChild', Matcher]]);\n    if (matcherNode !== null) {\n      const label = getLabel(matcherNode, text);\n      if (label !== null) {\n        labels.push(label);\n      }\n    }\n\n    // there might be more labels\n    listNode = walk(listNode, [['firstChild', Matchers]]);\n  }\n\n  // our labels-list is last-first, so we reverse it\n  labels.reverse();\n\n  return labels;\n}\n\nfunction resolveAfterUnwrap(node: SyntaxNode, text: string, pos: number): Situation | null {\n  return {\n    type: 'AFTER_UNWRAP',\n    logQuery: getLogQueryFromMetricsQueryAtPosition(text, pos).trim(),\n  };\n}\n\nfunction resolvePipeError(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // for example `{level=\"info\"} |`\n  const exprNode = walk(node, [\n    ['parent', PipelineStage],\n    ['parent', PipelineExpr],\n  ]);\n\n  if (exprNode === null) {\n    return null;\n  }\n\n  const { parent } = exprNode;\n\n  if (parent === null) {\n    return null;\n  }\n\n  if (parent.type.id === LogExpr || parent.type.id === LogRangeExpr) {\n    return resolveLogOrLogRange(parent, text, pos, true);\n  }\n\n  return null;\n}\n\nfunction resolveLabelsForGrouping(node: SyntaxNode, text: string, pos: number): Situation | null {\n  const aggrExpNode = walk(node, [['parent', VectorAggregationExpr]]);\n  if (aggrExpNode === null) {\n    return null;\n  }\n  const bodyNode = aggrExpNode.getChild('MetricExpr');\n  if (bodyNode === null) {\n    return null;\n  }\n\n  const selectorNode = walk(bodyNode, [\n    ['firstChild', RangeAggregationExpr],\n    ['lastChild', LogRangeExpr],\n    ['firstChild', Selector],\n  ]);\n\n  if (selectorNode === null) {\n    return null;\n  }\n\n  return {\n    type: 'IN_GROUPING',\n    logQuery: getLogQueryFromMetricsQueryAtPosition(text, pos).trim(),\n  };\n}\n\nfunction resolveMatcher(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // we can arrive here for two reasons. `node` is either:\n  // - a StringNode (like in `{job=\"^\"}`)\n  // - or an error node (like in `{job=^}`)\n  const inStringNode = !node.type.isError;\n\n  const parent = walk(node, [['parent', Matcher]]);\n  if (parent === null) {\n    return null;\n  }\n\n  const labelNameNode = walk(parent, [['firstChild', Identifier]]);\n  if (labelNameNode === null) {\n    return null;\n  }\n\n  const labelName = getNodeText(labelNameNode, text);\n\n  // now we need to go up, to the parent of Matcher,\n  // there can be one or many `Matchers` parents, we have\n  // to go through all of them\n\n  const firstListNode = walk(parent, [['parent', Matchers]]);\n  if (firstListNode === null) {\n    return null;\n  }\n\n  let listNode = firstListNode;\n\n  // we keep going through the parent-nodes as long as they are Matchers.\n  // as soon as we reach Selector, we stop\n  let selectorNode: SyntaxNode | null = null;\n  while (selectorNode === null) {\n    const parent = listNode.parent;\n    if (parent === null) {\n      return null;\n    }\n\n    switch (parent.type.id) {\n      case Matchers:\n        //we keep looping\n        listNode = parent;\n        continue;\n      case Selector:\n        // we reached the end, we can stop the loop\n        selectorNode = parent;\n        continue;\n      default:\n        // we reached some other node, we stop\n        return null;\n    }\n  }\n\n  // now we need to find the other names\n  const allLabels = getLabels(selectorNode, text);\n\n  // we need to remove \"our\" label from all-labels, if it is in there\n  const otherLabels = allLabels.filter((label) => label.name !== labelName);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_WITH_LABEL_NAME',\n    labelName,\n    betweenQuotes: inStringNode,\n    otherLabels,\n  };\n}\n\nfunction resolveLogfmtParser(_: SyntaxNode, text: string, cursorPosition: number): Situation | null {\n  // We want to know if the cursor if after a log query with logfmt parser.\n  // E.g. `{x=\"y\"} | logfmt ^`\n\n  const tree = parser.parse(text);\n\n  // Adjust the cursor position if there are spaces at the end of the text.\n  const trimRightTextLen = text.substring(0, cursorPosition).trimEnd().length;\n  const position = trimRightTextLen < cursorPosition ? trimRightTextLen : cursorPosition;\n\n  const cursor = tree.cursorAt(position);\n\n  // Check if the user cursor is in any node that requires logfmt suggestions.\n  const expectedNodes = [Logfmt, ParserFlag, LabelExtractionExpression, LabelExtractionExpressionList];\n  let inLogfmt = false;\n  do {\n    const { node } = cursor;\n    if (!expectedNodes.includes(node.type.id)) {\n      continue;\n    }\n    if (cursor.from <= position && cursor.to >= position) {\n      inLogfmt = true;\n      break;\n    }\n  } while (cursor.next());\n\n  if (!inLogfmt) {\n    return null;\n  }\n\n  const flags = getNodesFromQuery(text, [ParserFlag]).length > 1;\n  const labelNodes = getNodesFromQuery(text, [LabelExtractionExpression]);\n  const otherLabels = labelNodes\n    .map((label: SyntaxNode) => label.getChild(Identifier))\n    .filter((label: SyntaxNode | null): label is SyntaxNode => label !== null)\n    .map((label: SyntaxNode) => getNodeText(label, text));\n\n  return {\n    type: 'IN_LOGFMT',\n    otherLabels,\n    flags,\n    logQuery: getLogQueryFromMetricsQueryAtPosition(text, position).trim(),\n  };\n}\n\nfunction resolveTopLevel(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // we try a couply specific paths here.\n  // `{x=\"y\"}` situation, with the cursor at the end\n\n  const logExprNode = walk(node, [\n    ['lastChild', Expr],\n    ['lastChild', LogExpr],\n  ]);\n\n  if (logExprNode != null) {\n    return resolveLogOrLogRange(logExprNode, text, pos, false);\n  }\n\n  // `s` situation, with the cursor at the end.\n  // (basically, user enters a non-special characters as first\n  // character in query field)\n  const idNode = walk(node, [\n    ['firstChild', ERROR_NODE_ID],\n    ['firstChild', Identifier],\n  ]);\n\n  if (idNode != null) {\n    return {\n      type: 'AT_ROOT',\n    };\n  }\n\n  // no patterns match\n  return null;\n}\n\nfunction resolveDurations(node: SyntaxNode, text: string, pos: number): Situation {\n  return {\n    type: 'IN_RANGE',\n  };\n}\n\nfunction resolveLogRange(node: SyntaxNode, text: string, pos: number): Situation | null {\n  const partialQuery = text.substring(0, pos).trimEnd();\n  const afterPipe = partialQuery.endsWith('|');\n\n  return resolveLogOrLogRange(node, text, pos, afterPipe);\n}\n\nfunction resolveLogRangeFromError(node: SyntaxNode, text: string, pos: number): Situation | null {\n  const parent = walk(node, [['parent', LogRangeExpr]]);\n  if (parent === null) {\n    return null;\n  }\n\n  const partialQuery = text.substring(0, pos).trimEnd();\n  const afterPipe = partialQuery.endsWith('|');\n\n  return resolveLogOrLogRange(parent, text, pos, afterPipe);\n}\n\nfunction resolveLogOrLogRange(node: SyntaxNode, text: string, pos: number, afterPipe: boolean): Situation | null {\n  // Here the `node` is either a LogExpr or a LogRangeExpr\n  // We want to handle the case where we are next to a selector\n  const selectorNode = walk(node, [['firstChild', Selector]]);\n\n  // Check that the selector is before the cursor, not after it\n  if (!selectorNode || selectorNode.to > pos) {\n    return null;\n  }\n\n  return {\n    type: 'AFTER_SELECTOR',\n    afterPipe,\n    hasSpace: text.charAt(pos - 1) === ' ',\n    logQuery: getLogQueryFromMetricsQueryAtPosition(text, pos).trim(),\n  };\n}\n\nfunction resolveSelector(node: SyntaxNode, text: string, pos: number): Situation | null {\n  // for example `{^}`\n\n  // false positive:\n  // `{a=\"1\"^}`\n  const child = walk(node, [['firstChild', Matchers]]);\n  if (child !== null) {\n    // means the label-matching part contains at least one label already.\n    //\n    // in this case, we will need to have a `,` character at the end,\n    // to be able to suggest adding the next label.\n    // the area between the end-of-the-child-node and the cursor-pos\n    // must contain a `,` in this case.\n    const textToCheck = text.slice(child.from, pos);\n    if (!textToCheck.trim().endsWith(',')) {\n      return null;\n    }\n  }\n\n  const selectorNode =\n    node.type.id === ERROR_NODE_ID\n      ? walk(node, [\n          ['parent', Matchers],\n          ['parent', Selector],\n        ])\n      : node;\n  if (!selectorNode) {\n    return null;\n  }\n\n  const otherLabels = getLabels(selectorNode, text);\n\n  return {\n    type: 'IN_LABEL_SELECTOR_NO_LABEL_NAME',\n    otherLabels,\n  };\n}\n\nfunction resolveAfterKeepAndDrop(node: SyntaxNode, text: string, pos: number): Situation | null {\n  let logQuery = getLogQueryFromMetricsQueryAtPosition(text, pos).trim();\n  let keepAndDropParent: SyntaxNode | null = null;\n  let parent = node.parent;\n  while (parent !== null) {\n    if (parent.type.id === PipelineStage) {\n      keepAndDropParent = parent;\n      break;\n    }\n    parent = parent.parent;\n  }\n\n  if (keepAndDropParent?.type.id === PipelineStage) {\n    logQuery = logQuery.slice(0, keepAndDropParent.from);\n  }\n\n  return {\n    type: 'AFTER_KEEP_AND_DROP',\n    logQuery,\n  };\n}\n\n// we find the first error-node in the tree that is at the cursor-position.\n// NOTE: this might be too slow, might need to optimize it\n// (ideas: we do not need to go into every subtree, based on from/to)\n// also, only go to places that are in the sub-tree of the node found\n// by default by lezer. problem is, `next()` will go upward too,\n// and we do not want to go higher than our node\nfunction getErrorNode(tree: Tree, text: string, cursorPos: number): SyntaxNode | null {\n  // sometimes the cursor is a couple spaces after the end of the expression.\n  // to account for this situation, we \"move\" the cursor position back,\n  // so that there are no spaces between the end-of-expression and the cursor\n  const trimRightTextLen = text.trimEnd().length;\n  const pos = trimRightTextLen < cursorPos ? trimRightTextLen : cursorPos;\n  const cur = tree.cursorAt(pos);\n  do {\n    if (cur.from === pos && cur.to === pos) {\n      const { node } = cur;\n      if (node.type.isError) {\n        return node;\n      }\n    }\n  } while (cur.next());\n  return null;\n}\n\nexport function getSituation(text: string, pos: number): Situation | null {\n  // there is a special case when we are at the start of writing text,\n  // so we handle that case first\n\n  if (text === '') {\n    return {\n      type: 'EMPTY',\n    };\n  }\n\n  const tree = parser.parse(text);\n\n  // if the tree contains error, it is very probable that\n  // our node is one of those error nodes.\n  // also, if there are errors, the node lezer finds us,\n  // might not be the best node.\n  // so first we check if there is an error node at the cursor position\n  const maybeErrorNode = getErrorNode(tree, text, pos);\n\n  const cur = maybeErrorNode != null ? maybeErrorNode.cursor() : tree.cursorAt(pos);\n\n  const currentNode = cur.node;\n\n  const ids = [cur.type.id];\n  while (cur.parent()) {\n    ids.push(cur.type.id);\n  }\n\n  for (let resolver of RESOLVERS) {\n    for (let path of resolver.paths) {\n      if (isPathMatch(path, ids)) {\n        const situation = resolver.fun(currentNode, text, pos);\n        if (situation) {\n          return situation;\n        }\n      }\n    }\n  }\n\n  return null;\n}\n","import type { Monaco, monacoTypes } from '@grafana/ui';\n\nimport { CompletionDataProvider } from './CompletionDataProvider';\nimport { NeverCaseError } from './NeverCaseError';\nimport { getCompletions, CompletionType } from './completions';\nimport { getSituation } from './situation';\n\n// from: monacoTypes.languages.CompletionItemInsertTextRule.InsertAsSnippet\nconst INSERT_AS_SNIPPET_ENUM_VALUE = 4;\n\nexport function getSuggestOptions(): monacoTypes.editor.ISuggestOptions {\n  return {\n    // monaco-editor sometimes provides suggestions automatically, i am not\n    // sure based on what, seems to be by analyzing the words already\n    // written.\n    // to try it out:\n    // - enter `go_goroutines{job~`\n    // - have the cursor at the end of the string\n    // - press ctrl-enter\n    // - you will get two suggestions\n    // those were not provided by grafana, they are offered automatically.\n    // i want to remove those. the only way i found is:\n    // - every suggestion-item has a `kind` attribute,\n    //   that controls the icon to the left of the suggestion.\n    // - items auto-generated by monaco have `kind` set to `text`.\n    // - we make sure grafana-provided suggestions do not have `kind` set to `text`.\n    // - and then we tell monaco not to show suggestions of kind `text`\n    showWords: false,\n  };\n}\n\nfunction getMonacoCompletionItemKind(type: CompletionType, monaco: Monaco): monacoTypes.languages.CompletionItemKind {\n  switch (type) {\n    case 'DURATION':\n      return monaco.languages.CompletionItemKind.Unit;\n    case 'FUNCTION':\n      return monaco.languages.CompletionItemKind.Variable;\n    case 'HISTORY':\n      return monaco.languages.CompletionItemKind.Snippet;\n    case 'LABEL_NAME':\n      return monaco.languages.CompletionItemKind.Enum;\n    case 'LABEL_VALUE':\n      return monaco.languages.CompletionItemKind.EnumMember;\n    case 'PATTERN':\n      return monaco.languages.CompletionItemKind.Constructor;\n    case 'PARSER':\n      return monaco.languages.CompletionItemKind.Class;\n    case 'LINE_FILTER':\n      return monaco.languages.CompletionItemKind.TypeParameter;\n    case 'PIPE_OPERATION':\n      return monaco.languages.CompletionItemKind.Interface;\n    default:\n      throw new NeverCaseError(type);\n  }\n}\nexport function getCompletionProvider(\n  monaco: Monaco,\n  dataProvider: CompletionDataProvider\n): monacoTypes.languages.CompletionItemProvider {\n  const provideCompletionItems = (\n    model: monacoTypes.editor.ITextModel,\n    position: monacoTypes.Position\n  ): monacoTypes.languages.ProviderResult<monacoTypes.languages.CompletionList> => {\n    const word = model.getWordAtPosition(position);\n    const range =\n      word != null\n        ? monaco.Range.lift({\n            startLineNumber: position.lineNumber,\n            endLineNumber: position.lineNumber,\n            startColumn: word.startColumn,\n            endColumn: word.endColumn,\n          })\n        : monaco.Range.fromPositions(position);\n    // documentation says `position` will be \"adjusted\" in `getOffsetAt`\n    // i don't know what that means, to be sure i clone it\n    const positionClone = {\n      column: position.column,\n      lineNumber: position.lineNumber,\n    };\n    const offset = model.getOffsetAt(positionClone);\n    const situation = getSituation(model.getValue(), offset);\n    const completionsPromise = situation != null ? getCompletions(situation, dataProvider) : Promise.resolve([]);\n    return completionsPromise.then((items) => {\n      // monaco by default alphabetically orders the items.\n      // to stop it, we use a number-as-string sortkey,\n      // so that monaco keeps the order we use\n      const maxIndexDigits = items.length.toString().length;\n      const suggestions: monacoTypes.languages.CompletionItem[] = items.map((item, index) => ({\n        kind: getMonacoCompletionItemKind(item.type, monaco),\n        label: item.label,\n        insertText: item.insertText,\n        insertTextRules: item.isSnippet ? INSERT_AS_SNIPPET_ENUM_VALUE : undefined,\n        detail: item.detail,\n        documentation: item.documentation,\n        sortText: index.toString().padStart(maxIndexDigits, '0'), // to force the order we have\n        range,\n        command: item.triggerOnInsert\n          ? {\n              id: 'editor.action.triggerSuggest',\n              title: '',\n            }\n          : undefined,\n      }));\n      return { suggestions };\n    });\n  };\n\n  return {\n    triggerCharacters: ['{', ',', '[', '(', '=', '~', ' ', '\"', '|'],\n    provideCompletionItems,\n  };\n}\n","import { chain } from 'lodash';\n\nimport { HistoryItem } from '@grafana/data';\nimport { escapeLabelValueInExactSelector } from 'app/plugins/datasource/prometheus/language_utils';\n\nimport LanguageProvider from '../../../LanguageProvider';\nimport { LokiQuery } from '../../../types';\n\nimport { Label } from './situation';\n\ninterface HistoryRef {\n  current: Array<HistoryItem<LokiQuery>>;\n}\n\nexport class CompletionDataProvider {\n  constructor(\n    private languageProvider: LanguageProvider,\n    private historyRef: HistoryRef = { current: [] }\n  ) {}\n\n  private buildSelector(labels: Label[]): string {\n    const allLabelTexts = labels.map(\n      (label) => `${label.name}${label.op}\"${escapeLabelValueInExactSelector(label.value)}\"`\n    );\n\n    return `{${allLabelTexts.join(',')}}`;\n  }\n\n  getHistory() {\n    return chain(this.historyRef.current)\n      .map((history: HistoryItem<LokiQuery>) => history.query.expr)\n      .filter()\n      .uniq()\n      .value();\n  }\n\n  async getLabelNames(otherLabels: Label[] = []) {\n    if (otherLabels.length === 0) {\n      // if there is no filtering, we have to use a special endpoint\n      return this.languageProvider.getLabelKeys();\n    }\n    const data = await this.getSeriesLabels(otherLabels);\n    const possibleLabelNames = Object.keys(data); // all names from datasource\n    const usedLabelNames = new Set(otherLabels.map((l) => l.name)); // names used in the query\n    return possibleLabelNames.filter((label) => !usedLabelNames.has(label));\n  }\n\n  async getLabelValues(labelName: string, otherLabels: Label[]) {\n    if (otherLabels.length === 0) {\n      // if there is no filtering, we have to use a special endpoint\n      return await this.languageProvider.getLabelValues(labelName);\n    }\n\n    const data = await this.getSeriesLabels(otherLabels);\n    return data[labelName] ?? [];\n  }\n\n  async getParserAndLabelKeys(logQuery: string) {\n    return await this.languageProvider.getParserAndLabelKeys(logQuery);\n  }\n\n  async getSeriesLabels(labels: Label[]) {\n    return await this.languageProvider.getSeriesLabels(this.buildSelector(labels)).then((data) => data ?? {});\n  }\n}\n","import { css } from '@emotion/css';\nimport { debounce } from 'lodash';\nimport React, { useRef, useEffect } from 'react';\nimport { useLatest } from 'react-use';\nimport { v4 as uuidv4 } from 'uuid';\n\nimport { GrafanaTheme2 } from '@grafana/data';\nimport { selectors } from '@grafana/e2e-selectors';\nimport { languageConfiguration, monarchlanguage } from '@grafana/monaco-logql';\nimport { useTheme2, ReactMonacoEditor, Monaco, monacoTypes, MonacoEditor } from '@grafana/ui';\n\nimport { Props } from './MonacoQueryFieldProps';\nimport { getOverrideServices } from './getOverrideServices';\nimport { getCompletionProvider, getSuggestOptions } from './monaco-completion-provider';\nimport { CompletionDataProvider } from './monaco-completion-provider/CompletionDataProvider';\nimport { placeHolderScopedVars, validateQuery } from './monaco-completion-provider/validation';\n\nconst options: monacoTypes.editor.IStandaloneEditorConstructionOptions = {\n  codeLens: false,\n  contextmenu: false,\n  // we need `fixedOverflowWidgets` because otherwise in grafana-dashboards\n  // the popup is clipped by the panel-visualizations.\n  fixedOverflowWidgets: true,\n  folding: false,\n  fontSize: 14,\n  lineDecorationsWidth: 8, // used as \"padding-left\"\n  lineNumbers: 'off',\n  minimap: { enabled: false },\n  overviewRulerBorder: false,\n  overviewRulerLanes: 0,\n  padding: {\n    // these numbers were picked so that visually this matches the previous version\n    // of the query-editor the best\n    top: 4,\n    bottom: 5,\n  },\n  renderLineHighlight: 'none',\n  scrollbar: {\n    vertical: 'hidden',\n    verticalScrollbarSize: 8, // used as \"padding-right\"\n    horizontal: 'hidden',\n    horizontalScrollbarSize: 0,\n  },\n  scrollBeyondLastLine: false,\n  suggest: getSuggestOptions(),\n  suggestFontSize: 12,\n  wordWrap: 'on',\n};\n\n// this number was chosen by testing various values. it might be necessary\n// because of the width of the border, not sure.\n//it needs to do 2 things:\n// 1. when the editor is single-line, it should make the editor height be visually correct\n// 2. when the editor is multi-line, the editor should not be \"scrollable\" (meaning,\n//    you do a scroll-movement in the editor, and it will scroll the content by a couple pixels\n//    up & down. this we want to avoid)\nconst EDITOR_HEIGHT_OFFSET = 2;\n\nconst LANG_ID = 'logql';\n\n// we must only run the lang-setup code once\nlet LANGUAGE_SETUP_STARTED = false;\n\nfunction ensureLogQL(monaco: Monaco) {\n  if (LANGUAGE_SETUP_STARTED === false) {\n    LANGUAGE_SETUP_STARTED = true;\n    monaco.languages.register({ id: LANG_ID });\n\n    monaco.languages.setMonarchTokensProvider(LANG_ID, monarchlanguage);\n    monaco.languages.setLanguageConfiguration(LANG_ID, languageConfiguration);\n  }\n}\n\nconst getStyles = (theme: GrafanaTheme2, placeholder: string) => {\n  return {\n    container: css`\n      border-radius: ${theme.shape.radius.default};\n      border: 1px solid ${theme.components.input.borderColor};\n      width: 100%;\n      .monaco-editor .suggest-widget {\n        min-width: 50%;\n      }\n    `,\n    placeholder: css`\n      ::after {\n        content: '${placeholder}';\n        font-family: ${theme.typography.fontFamilyMonospace};\n        opacity: 0.3;\n      }\n    `,\n  };\n};\n\nconst MonacoQueryField = ({ history, onBlur, onRunQuery, initialValue, datasource, placeholder, onChange }: Props) => {\n  const id = uuidv4();\n  // we need only one instance of `overrideServices` during the lifetime of the react component\n  const overrideServicesRef = useRef(getOverrideServices());\n  const containerRef = useRef<HTMLDivElement>(null);\n\n  const langProviderRef = useLatest(datasource.languageProvider);\n  const historyRef = useLatest(history);\n  const onRunQueryRef = useLatest(onRunQuery);\n  const onBlurRef = useLatest(onBlur);\n\n  const autocompleteCleanupCallback = useRef<(() => void) | null>(null);\n\n  const theme = useTheme2();\n  const styles = getStyles(theme, placeholder);\n\n  useEffect(() => {\n    // when we unmount, we unregister the autocomplete-function, if it was registered\n    return () => {\n      autocompleteCleanupCallback.current?.();\n    };\n  }, []);\n\n  const setPlaceholder = (monaco: Monaco, editor: MonacoEditor) => {\n    const placeholderDecorators = [\n      {\n        range: new monaco.Range(1, 1, 1, 1),\n        options: {\n          className: styles.placeholder,\n          isWholeLine: true,\n        },\n      },\n    ];\n\n    let decorators: string[] = [];\n\n    const checkDecorators: () => void = () => {\n      const model = editor.getModel();\n\n      if (!model) {\n        return;\n      }\n\n      const newDecorators = model.getValueLength() === 0 ? placeholderDecorators : [];\n      decorators = model.deltaDecorations(decorators, newDecorators);\n    };\n\n    checkDecorators();\n    editor.onDidChangeModelContent(checkDecorators);\n  };\n\n  const onTypeDebounced = debounce(async (query: string) => {\n    onChange(query);\n  }, 1000);\n\n  return (\n    <div\n      aria-label={selectors.components.QueryField.container}\n      className={styles.container}\n      // NOTE: we will be setting inline-style-width/height on this element\n      ref={containerRef}\n    >\n      <ReactMonacoEditor\n        overrideServices={overrideServicesRef.current}\n        options={options}\n        language={LANG_ID}\n        value={initialValue}\n        beforeMount={(monaco) => {\n          ensureLogQL(monaco);\n        }}\n        onMount={(editor, monaco) => {\n          // Monaco has a bug where it runs actions on all instances (https://github.com/microsoft/monaco-editor/issues/2947), so we ensure actions are executed on instance-level with this ContextKey.\n          const isEditorFocused = editor.createContextKey<boolean>('isEditorFocused' + id, false);\n          // we setup on-blur\n          editor.onDidBlurEditorWidget(() => {\n            isEditorFocused.set(false);\n            onBlurRef.current(editor.getValue());\n          });\n          editor.onDidChangeModelContent((e) => {\n            const model = editor.getModel();\n            if (!model) {\n              return;\n            }\n            const query = model.getValue();\n            const errors =\n              validateQuery(\n                query,\n                datasource.interpolateString(query, placeHolderScopedVars),\n                model.getLinesContent()\n              ) || [];\n\n            const markers = errors.map(({ error, ...boundary }) => ({\n              message: `${\n                error ? `Error parsing \"${error}\"` : 'Parse error'\n              }. The query appears to be incorrect and could fail to be executed.`,\n              severity: monaco.MarkerSeverity.Error,\n              ...boundary,\n            }));\n\n            onTypeDebounced(query);\n            monaco.editor.setModelMarkers(model, 'owner', markers);\n          });\n          const dataProvider = new CompletionDataProvider(langProviderRef.current, historyRef);\n          const completionProvider = getCompletionProvider(monaco, dataProvider);\n\n          // completion-providers in monaco are not registered directly to editor-instances,\n          // they are registered to languages. this makes it hard for us to have\n          // separate completion-providers for every query-field-instance\n          // (but we need that, because they might connect to different datasources).\n          // the trick we do is, we wrap the callback in a \"proxy\",\n          // and in the proxy, the first thing is, we check if we are called from\n          // \"our editor instance\", and if not, we just return nothing. if yes,\n          // we call the completion-provider.\n          const filteringCompletionProvider: monacoTypes.languages.CompletionItemProvider = {\n            ...completionProvider,\n            provideCompletionItems: (model, position, context, token) => {\n              // if the model-id does not match, then this call is from a different editor-instance,\n              // not \"our instance\", so return nothing\n              if (editor.getModel()?.id !== model.id) {\n                return { suggestions: [] };\n              }\n              return completionProvider.provideCompletionItems(model, position, context, token);\n            },\n          };\n\n          const { dispose } = monaco.languages.registerCompletionItemProvider(LANG_ID, filteringCompletionProvider);\n\n          autocompleteCleanupCallback.current = dispose;\n          // this code makes the editor resize itself so that the content fits\n          // (it will grow taller when necessary)\n          // FIXME: maybe move this functionality into CodeEditor, like:\n          // <CodeEditor resizingMode=\"single-line\"/>\n          const handleResize = () => {\n            const containerDiv = containerRef.current;\n            if (containerDiv !== null) {\n              const pixelHeight = editor.getContentHeight();\n              containerDiv.style.height = `${pixelHeight + EDITOR_HEIGHT_OFFSET}px`;\n              const pixelWidth = containerDiv.clientWidth;\n              editor.layout({ width: pixelWidth, height: pixelHeight });\n            }\n          };\n\n          editor.onDidContentSizeChange(handleResize);\n          handleResize();\n          // handle: shift + enter\n          // FIXME: maybe move this functionality into CodeEditor?\n          editor.addCommand(\n            monaco.KeyMod.Shift | monaco.KeyCode.Enter,\n            () => {\n              onRunQueryRef.current(editor.getValue());\n            },\n            'isEditorFocused' + id\n          );\n\n          editor.onDidFocusEditorText(() => {\n            isEditorFocused.set(true);\n            if (editor.getValue().trim() === '') {\n              editor.trigger('', 'editor.action.triggerSuggest', {});\n            }\n          });\n\n          setPlaceholder(monaco, editor);\n        }}\n      />\n    </div>\n  );\n};\n\n// Default export for lazy load.\nexport default MonacoQueryField;\n","import { useRef } from 'react';\nvar useLatest = function (value) {\n    var ref = useRef(value);\n    ref.current = value;\n    return ref;\n};\nexport default useLatest;\n"],"names":["exports","aggregations","parsers","format_expressions","vector_aggregations","vector_matching","vectorMatchingRegex","prev","curr","operators","keywords","makeStorageService","strings","data","key","scope","fallbackValue","val","value","target","reason","overrideServices","getOverrideServices","NeverCaseError","LOG_COMPLETIONS","AGGREGATION_COMPLETIONS","f","FUNCTION_COMPLETIONS","BUILT_IN_FUNCTIONS_COMPLETIONS","DURATION_COMPLETIONS","text","UNWRAP_FUNCTION_COMPLETIONS","LOGFMT_ARGUMENT_COMPLETIONS","LINE_FILTER_COMPLETIONS","getLineFilterCompletions","afterPipe","completion","operator","documentation","getPipeOperationsCompletions","prefix","completions","getAllHistoryCompletions","dataProvider","expr","getLabelNamesForSelectorCompletions","otherLabels","label","getInGroupingCompletions","logQuery","extractedLabelKeys","PARSERS","getParserCompletions","hasJSON","hasLogfmt","hasPack","hasParserInQuery","allParsers","hasLevelInExtractedLabels","extra","parser","getAfterSelectorCompletions","hasSpace","query","hasQueryParser","parserCompletions","pipeOperations","getLogfmtCompletions","flags","trailingComma","labelPrefix","labelCompletions","getLabelValuesForMetricCompletions","labelName","betweenQuotes","getAfterUnwrapCompletions","unwrapLabelKeys","getAfterKeepAndDropCompletions","getCompletions","situation","move","node","direction","walk","path","current","expectedNode","getNodeText","parseStringLiteral","inside","isPathMatch","resolverPath","cursorPath","item","index","ERROR_NODE_ID","RESOLVERS","resolveSelector","resolveLogfmtParser","resolveTopLevel","resolveMatcher","resolveLabelsForGrouping","resolveLogRange","resolveDurations","resolveLogRangeFromError","resolvePipeError","resolveAfterUnwrap","resolveAfterKeepAndDrop","LABEL_OP_MAP","getLabelOp","opNode","getLabel","matcherNode","nameNode","op","valueNode","name","getLabels","selectorNode","listNode","labels","pos","exprNode","parent","resolveLogOrLogRange","aggrExpNode","bodyNode","inStringNode","labelNameNode","firstListNode","_","cursorPosition","tree","trimRightTextLen","position","cursor","expectedNodes","inLogfmt","logExprNode","child","keepAndDropParent","getErrorNode","cursorPos","cur","getSituation","maybeErrorNode","currentNode","ids","resolver","INSERT_AS_SNIPPET_ENUM_VALUE","getSuggestOptions","getMonacoCompletionItemKind","type","monaco","getCompletionProvider","model","word","range","positionClone","offset","items","maxIndexDigits","CompletionDataProvider","languageProvider","historyRef","history","possibleLabelNames","usedLabelNames","l","options","EDITOR_HEIGHT_OFFSET","LANG_ID","LANGUAGE_SETUP_STARTED","ensureLogQL","getStyles","theme","placeholder","onBlur","onRunQuery","initialValue","datasource","onChange","id","overrideServicesRef","containerRef","langProviderRef","useLatest","onRunQueryRef","onBlurRef","autocompleteCleanupCallback","styles","setPlaceholder","editor","placeholderDecorators","decorators","checkDecorators","newDecorators","onTypeDebounced","selectors","isEditorFocused","e","markers","error","boundary","completionProvider","filteringCompletionProvider","context","token","dispose","handleResize","containerDiv","pixelHeight","pixelWidth","ref"],"sourceRoot":""}